# Me

## **自我介绍**

我叫李文韬，来自武汉理工大学，现在读大四。

我从20年5月左右开始自学前端，也有一年多的时间。

主要的学习方式是找国内外的视频（教程、发布会）和文章等。



**个人经历：**

这个暑假在北京好未来学而思网校实习了三个月，主要负责网校的Web直播课堂相关的业务和相关的重构工作。算是网校技术水平较高的项目。

同时也参与了部分网校前端组的技术小组在整个网校研发部标准工程的制定工作。

同时在实习之前，我也和大学的同学参加了一些团队比赛，做了一些相关的项目，其中分别涉及了 Web3D 和 深度学习 的领域。



总的来说，挺喜欢前端这个方向，也有很多探索的空间，未来也计划向更深的方向去探索。



# Projects

## 项目介绍

### 学而思网校直播课堂 WebTboard

**直播课堂是什么？**

学而思网校的直播课堂是整个网校的核心教学应用，它面向教师、学生分为不同的端，教师端为iPad端 , 学生端有Android IOS PC Web多个端。

而我负责的是学生直播端的Web部分，负责开发板书工具 涂鸦画板SDK的功能。



**涂鸦画板是什么？**

教师端在iPad上进行板书、绘图、以及作出编辑操作等、我们其它各端对绘制和操作作出同步的展示。

在Web端上使用的是HTML Canvas的原生API进行绘制。



我个人负责的是整个套索功能的开发 。

教师批量地选取多个涂鸦、图形，可进行大批量的移动、缩放旋转、修改样式等操作。而在Web端上，我们对服务器推送的数据进行同步的展示。

图形的变换操作涉及到对Canvas2D的变换API进行组合。

同时，为了保证操作的撤销、回复功能，在Web端本地设计了一套数据结构来保存变换记录。



性能优化相关：

1. 利用矩阵进行数据降维：

在此之后，个人在还利用了变换矩阵的相关知识，利用矩阵总结出通用公式，对历史的操作数据进行了降维。

经过本地的自测统计，大批量涂鸦数据的绘制时长很可观，降低由65%- 90%, 节点越多，能节省的时间就越多。



降维基本原理：把多次小套索和成一个大套索。把每一个Canvas API的变换操作参数对应成3x3的变换矩阵，API之间的组合对应成矩阵的相乘操作。3x3的矩阵操作，最后合成的也是一个3x3矩阵，而这个最终的矩阵就代表了前面一个数组的所有操作。



为保证操作的次序正确，优化前方案是利用数组增量地存放变换数据，n个图形,m次套索变换，那么用于表示和实现一次套索状态的时间、空间复杂度就是$O(n^2)$。如果我们把m次套索变换合成一次，就直接减少了一个维度的时间复杂度。



在优化完成之后，我们对性能进行了检测，主要测试是图形绘制的速度。在大批量图形密集触发的情况之下，优化的效果也越好。



这是第一个优化点。



第二个优化点，使用离屏Canvas进行图形的缓存。用户操作图形时，画布上的图形有被选中、未被选中之分。而canvas在每次重绘时，都要清除所有的图形，再根据新的数据点进行重绘。

而我们在一系列的连续操作时，未选中的图形是不会改变的。因此我们在第一次绘制时，使用内存canvas缓存了一份图形，在这本次操作的下一次触发时，直接绘制一次缓存canvas。



第三个 SDK的未来展望

希望能拓展出一个泛用的SDK，利用形成组件 + Hooks的形式，参考React-Three-Fiber的方式，利用JSX函数进行开发。



### 前端标准工程项目

我的实习导师同时也是网校研发部前端技术小组的负责人，因此个人还有幸参与了网校研发前端组技术小组有关标准工程的建设项目。

该项目的目的是为整个前端组建立一套示范性的开发流程。给前端组今后新项目的发展、旧项目的维护提供统一的参考。



整个前端工程化设计的流程是包含很多环节的。

核心 ： **标准 与 规范 + 工具 与 资源+ 自动化流程**



再细节地去划分：

**开发规范** **研发流程** **项目和工程管理**



**资产** —— 开发工具、组件库 、服务器资源等



**自动化代码扫描** => 代码风格、安全防控

**自动化错误监控与上报**

**自动化测试** => 质量保障



在此之外，在有相关工具的支持 如前端组CLI工具、性能监控平台等环节 向可视化一站式工具的升级。

本人负责的是规范文档平台的搭建，包括了自动化的文档提交，Gitlab仓库 => CI/CD 进行代码扫描 => 好未来云服务k8s 的自动化部署流程。

它为整体的制度规范提供服务。它也是整个前端研发工程化的基础准备中的一部分。



### Web3D 校园应用

### 深度学习APP



## 涉及技术

### 微前端架构

**背景**

微前端架构本质上是利用了服务端微服务的思想。在微服务的架构中，我们常把不同的路由分散在不同的主机之上，把一个应用逻辑分成独立的部分，服务和服务之间形成了非常松的耦合。

在前端中我们也可以采用这样的思想，我们可以把一个前端应用的不功能模块来进行拆分，形成多个松耦合的，功能各自独立的许多个子应用



**解决的问题：**

1. 代码管理：
   - 权限管控
   - commit 混乱、分支混乱
2. 开发流程：
   - 构建时间长
   - 技术体系要求统一
   - 调试入口深
3. 发布上线：
   - 无法同时灰度多产品
   - 代码回滚相互影响
   - 发布相互影响

**好处**：

- 各个模块之间功能，逻辑清晰，且满足了**单一责任原则**,一个应用只做一件业务

- **技术异构**：我们可以为不同的功能去选择不同的技术架构，不同的依赖库，而他们之间因不相互依赖，也不必去相互照顾

- 应用间的**低耦合**：它们若一个应用出现了故障，对其它应用的影响能减到最小



方案选型：qiankun / Webpack ModuleFederation Plugin（EMP架构）

Qiankun —— 中心化基座架构，多个子应用向基座应用聚合，父子应用之间以HTML Entry形式，而HTML就包含了所有子应用的信息（CSS 、JS等资源的列表）。



Webpack ModuleFedetation —— 去中心化的微前端架构，任何应用可以是容器应用（父应用），自身也可以作为子应用被其它容器应用引入。应用和应用之间形成树状的结构。



考虑单个应用，在我们应用代码分块（code splitting）时，我们使用动态的引入法方引入模组，在真正到达到某个路由时才发出HTTP请求，去得到对应的模块，这里的模块也就是JS文件。在应用中，每个应用我们都使用Webpack进行打包处理，Webpack打包的结果是相应应用完整的代码块，它们本质上能放在任意一个静态服务器，完全能独自实现自己的功能。应用中引入外部的模组应用和引入本地的模组本质上没有任何区别，因此Webpack就可以做到这一点。



而无论是qiankun或是webpack，所有微前端架构都要解决几个问题 —— 应用间的相互 **挂载、通信、隔离** 问题。

1. **应用间的挂载：** 应用之间应该是技术无关的，因此应用之间不应提供某个框架的具体挂载方法，而是提供*“抽象的生命周期”*方法，如 **mount** **unmount** ，向下提供容器应用的DOM容器（挂载目标），而由子应用调自身的框架挂载方法进行应用的挂载。
2. **应用间的通信：** 在核心的容器上层，布置了采用发布订阅模式的消息中心，对多应用之间的消息进行转发。而在具体的应用之间的接口之上，我们采用回调函数的方式进行数据的传递。微前端应用间应是技术相互独立的，包括了它们之间的依赖，但它们之间都是web应用，也必然支持JS的回调函数进行传参。
3. **应用间的隔离：** 应用间CSS样式的隔离 => 利用工程化手段（CSS Module / CSS in JS）,把CSS类名进行后处理



我们选用emp架构（Webpack ModuleFederation）的理由：

1. 基于源有Webpack架构的升级较为容易，能做出尽量小的改动进行改造。学而思内部的Webpack的配置项可尽可能地复用
2. 有应用之间的嵌套关系

### Protobuf

Google 开发的一套用于高效存放、读取数据的工具，和JSON十分类似，但Protobuf 能比JSON更高效，原因在于：

1. Protobuf 以二进制格式传输、不保存格式只保存数据，体量非常小。
2. Protobuf 在发送和接收双方都需要约定以proto格式定义好的格式文件，进行编码和解码
3. 可以在多端不同的语言环境搭配相应的库使用



之所以选用protobuf传输，是因为一场直播课堂的传输数据十分密集，而需要保证低延时



### React-Three-Fiber

React Three Fiber 是一个Three.js 的 React 渲染器， 它能把我们 利用JSX语法生成的React VirtualDOM对应动态生成Three.js语法，并把这些对象动态加入画布之中。

而Three.js 本质上利用WebGL来绘制3D效果的，WebGL是非常底层的系统，只处理点，线，三角型。利用WebGL提供的API，书写OpenGL，我们可以操作GPU进行渲染。



但，它是十分底层的系统，如果我们要开发较完善的，实用的应用，我们就要使用封装库Three.js了，而原生Three.js 一般基于ES6的`class` 来开发，对于一些中大型应用的开发，代码量大，逻辑不清，难以重用。



而我们使用React Three Fiber的原因是我们希望充分利用React应用提供的优势：声明式的编程，组件的重用性，React的状态机制，更新机制，以及React强大的社区生态。



我们所写的React组件，在React内部以VirtualDOM中ReactNode的形式来表现，（更准确来说，是一个个的Fiber对象，这也是这个库名中Fiber字样的由来）。React 通过Diffing（Reconcliation）的过程为我们找出更新目标，再提交到React - Three - Fiber渲染器中进行ReactFiber节点（Patches）到Three.js对象的生成和更新。



性能方面，对比原生Three.js应用来说，它并不会因为引入了额外的更新机制而有所差别，因为Three.js的渲染循环在React之外，那并不是React负责的。



如所有使用VirtualDOM机制的架构一样，VirtualDOM保证的是一个性能的下限，无须手动操作原生API，也能为我们提供过得去的性能。



### WebRTC

优网直播使用RTC进行视频、音频、课件推流。充分利用了WebRTC低延迟的特点



**WebRTC简要原理**

在一般情况下，我们相要在两个设备之间相互进行通信，最简单的方法是通过一个中介服务器（充当接线员或邮局），由服务器对消息进行转发。（绿线）

缺点也很明显，它经过了向服务器的额外传输，这必定会带来延迟。如果我们的每帧视频都使用这种方式传输，那是非常不理想的。

如果我们有办法能让两个客户端直接通信，不经过中间者，那么它们的延迟就有望降低了。WebRTC为解决这个问题而设计。（蓝线）

<img src="/Users/tonylee/Library/Application Support/typora-user-images/image-20211017223143540.png" alt="image-20211017223143540" style="zoom:50%;" />

怎么做到的？

要想在设备间传输信息，理论上只要知道它们之间的IP地址，就可以去发信。由于现代网络防火墙等保护机制，用户之间不受信，是不能够直接相连的。因此它们需要一个中间服务器作两者之间的“媒人”，也就是TURN 服务器。

<img src="/Users/tonylee/Library/Application Support/typora-user-images/image-20211017223158523.png" alt="image-20211017223158523" style="zoom:50%;" />

它们之间通过交换**SDP**(Session Description Protocal)，确认相互之间可以通信：

理论上，只要把这段信息以某种方式发送给对方，就可以建立WebRTC通信，所以用知音楼以文字发出去也是可以的。

这个过程叫作**RTC Signaling**

然后，在客户端浏览器中建立RTCPeerConnection，就可以进行相互通信，之后处理后的媒体流就可以在两者之间直接传输，不需要服务器中转，实现视频流的低延时传输。



### Canvas vs SVG

- SVG：以矢量形式表示图形，直接放入DOM之中，能进行相关的DOM操作和事件的注册，它能很好地利用CSS属性、动画，比较适合小批量、小区域的图形
- Canvas：以像素形式表示图形，提供像素级别的操作，有更好的JS动画性能，比较适合大批量图形的动画



## 优化应用性能

- 性能检测的方法
  - 整体指标：使用Devtool中的Performance工具，来观察3D应用最主要的一个参数，也就是FPS。
  - 组件指标：使用React16 提供的 Profiler工具，来观察组件的更新频率。
  - 网络指标：在Network Tab中可看到请求数量，请求文件的大小，处理时间
- React
  - 赖加载组件 - 使用模组的动态引入，和微前端架构 + 路由进行配合，能达到按需加载的目的，减少一次性请求过量的代码和模型
  - 记忆 
    - 减少重复执行繁重计算 ： `useMemo()`,`useCallback()`
    - 减少重复渲染 : `React.memo()` 高阶记忆组件
  - 给列表组件提供`key`属性，帮助React找出列表组件变化时的不变量，减少重复渲染
  - 表现优化，我们使用React16的`<Suspense>`组件，并提供组件未加载时的回滚值，来提高表现性
- 网络传输/资源
  - 为传输模型进行压缩，能减少网络传输时间，主要应用了Draco，一个由Google开发，开源的3D模型压缩库
  - 为我们的模型使用`gltf` /`glb`的二进制格式，更好的适配Three.js 应用，加载的速度也更快
- Three.js
  - 我们使用了拓展库 `react-spring` 来实现物理效果，如果能减少物体之间无效的干涉，就能减少无用的物理计算
  - 减少使用高消耗的光线，阴影



# HTML

## H5 标签

具体功能：`<code>` `<detail>` `<title>`

布局： `<header>` `<main>` `<footer>` `<aside>` `<nav>` `<section>`

媒体 `<canvas>`  `<video>` `<audio>`

## 语义化

1. 在有这些语义化的标签之前，我们通常会使用`<div>` 或`<span>`来表示一个区块，并加上**类名**来作实质上功能性的区分。这样既有**命名冲突**的可能，也使得整个 HTML 文件**可读性很差**，再加上开发者对命名之间**没有一个统一的标准**，会变得很难维护。

   在正确的地方使用正确的标签，使得**语义明确，功能清晰**。

2. 有利于更好地配合**搜索引擎**，使其能爬取更多的内容
3. 有利于更好地支持**阅读模式的设备**



## async 和 defer

默认情况下，当浏览器在解析 HTML 文件中遇到`<script>`脚本时，会马上停止页面的渲染，立刻去下载和执行脚本文件。此时我们的页面可能加载不完整。这两个属性都是为了控制 JavaScript 的下载和执行而设的。

- defer 会告诉浏览器，脚本可以**立刻下载**，但延后到整个页面加载完成之后再运行
- async 脚本会立刻下载，但在**下载完成**之后会马上执行，它既不保证执行顺序，也有可能在页面加载完成前运行 （优先触发）



## Meta 标签

TML 的一个结构性文件，主要表明了文件的一些主要信息 如标题，概述，关键词等来帮助搜索引擎来了解页面内容。它也定义了文档初始的**视野范围**，**初始缩放**等等。



## Link 标签 和 CSS 中 @import 

在解析 HTML 时遇到`<link>`标签，会同时加载引用的 CSS，而用`@import`引入会在页面完全加载完毕之后再加载

`<link>`的向下兼容性比较强，支持低版本浏览器，CSS2.1 之后才支持`@import`



## 大量 DOM 元素的优化

1. 减少反复地进行 DOM 查询，可先将不必循环的根结点缓存。
2. 用`innerHTML`代替直接`appendChild`，以操作字符串来代替操作 DOM
3. 使用 React/Vue 类似的 VirtualDOM 架构



## 如何进行 SEO 优化？

1. 设置合理的 meta Data：尽量用简洁的语言来表示`title`,`description`，`keyword`等
2. 使用语义化的标签
3. 为img加上`alt` 属性和 `title`属性，canvas加上默认DOM
4. 页面尽量扁平化，层级不要过深（3 级）
5. 重点要突出



## src 和 href

- `href`是指对某个资源的引用，指向特定的位置，旨在建立某种联系， 而`src`用于替换当前的内容
- 下载方式的不同： 解析到`src` 的时候，会优先下载该资源，解析，执行。在此时，渲染线程会被阻塞



## `clientTop`,`offsetTop`,`scrollTop` 的区别

offset => 元素的 可见范围 + 滚动条 + border

scroll => 元素的可见 + 不可见的内容

client => 元素的可见内容



##  `<image>`元素中`alt`和`title`的区别和作用？

- `alt`: 当文件下载失败时，会显示默认的文字以代替的图片；
- `title`：当用户的鼠标放置在图片之上时，会显示一些补充说明信息
- 以上两者都有助于 SEO 优化，能给予搜索引擎更多的信息





# CSS

## BFC

- BFC (Box Formatting Context )是 CSS 中块级布局的一个基本单位。它可以被认为是一个独立的布局容器，有自己渲染区域。它的布局不会影响到它外部的元素，外部元素也不会影响到它的内部。
- 根浮位溢 FGI
  - 根元素
  - 浮动元素 `float:left `|` float:right`
  - 定位元素（完全脱离文档流）`absolute` | `fixed`
  - 溢出元素 （非`visible`）
  - `flex` | `grid`|`inline-box`
- 用处
  - 可用于清除浮动
  - 可用于防止上下边缘重叠
  - 防止元素被浮动元素所遮盖

## 清除浮动

应用浮动时产生的副作用是浮动元素脱离了文档流，其它兄弟元素会忽略这个浮动元素的存在而进行重排，而父元素的高度也可能因此而改变

清除浮动造成的影响的方法有

\- 使父元素触发 BFC`overflow:hidden` ，BFC 会计入浮动子元素的高度

\- 利用空元素 配合使用 `clear` 属性。 `clear`属性定义了它在某个方向上不能有浮动元素

具体的使用方法：

使用空`<div>`

```css
.clear-element {
  clear: both;
  height: 0;
  overflow: hidden;
}
```

使用伪元素 (理解为墙)

```css
.container::after,
.container::before {
  clear: both;
  content: '';
  display: block;
}
```

空`<div>`对比伪元素:

空`<div>`在文档中加入了无实际语义的元素，把样式设计引入文档结构中，使得页面的结构和样式功能混杂

## block vs inline vs inline-block

- block 块级元素，默认由上到下进行排布，可设宽高，每个元素占一行

- inline 行内元素，默认由左到右进行排布，不可设宽，高，垂直 margin 和 padding ，它的高可以由行高定义
- inline-block 行内块元素表现为是行内元素，但加上了块级元素的属性，如可设宽高，垂直边缘等，`<img>`和`<input>`等

## 元素的居中



- inline => `text-align: center`   

- position: absolute + top: 50% + transforam : translate(-50%, -50%)

- position: absolute + top: 50% + margin-top: 0.5 X height

- Flex

  



## 常见布局的实现

### 单列布局 (同宽) **（margin-horizontal :auto）**

```html
<body>
  <header>Header</header>
  <div id="content">Main</div>
  <footer>Footer</footer>
</body>
```

```css
header {
  /*防止屏幕宽小于1000px 出现滚动条*/
  max-width: 1000px;

  /* 居中 */
  margin: 30px auto;
}

#content {
  max-width: 1000px;
  margin: 30px auto;
  height: 80vh;
}

footer {
  max-width: 1000px;
  margin: 30px auto;
}
```

### 三列自适应布局 **(两边绝对定位)**

```html
<div id="main">Middle</div>
<div id="left">Left</div>
<div id="right">Right</div>
```

```css
#left {
  width: 200px;
  height: 100vh;

  position: absolute;
  top: 0;
  left: 0;
}

#right {
  width: 200px;
  height: 100vh;

  position: absolute;
  top: 0;
  right: 0;
}

#main {
  margin: 0 200px;
  height: 100vh;
}
```

### 双飞翼布局

```html
<header>Header</header>
<div class="wrapper">
  <div class="center">Center</div>
</div>
<div class="left">Left</div>
<div class="right">Right</div>
<footer>Footer</footer>
```

```css
header {
  width: 100%;
  height: 100px;
}

footer {
  width: 100%;
  height: 100px;

  /*  由footer 负责清空浮动*/
  clear: both;
}

.wrapper {
  width: 100%;
  float: left;
}

.center {
  margin: 0 200px;
}

.left {
  width: 200px;
  float: left;
  margin-left: -100%;
}

.right {
  width: 200px;
  float: left;
  margin-left: -200px;
}
```

### 圣杯布局

步骤：

- 主内容置顶，三者都浮动，
- 切换位置 ( 负的 margin-left )
- 容器 padding 撑开

```html
<header>Header</header>
<div class="wrapper clear-fix">
  <div class="center">Center</div>
  <div class="left">Left</div>
  <div class="right">Right</div>
</div>
<footer>Footer</footer>
```

```css
header,
footer {
  width: 100%;
  height: 50px;
}

/*对wrapper清除浮动*/
.clear-fix::before,
.clear-fix::after {
  content: '';
  display: block;
  clear: both;
}

.wrapper {
  padding: 0 200px;
}

.left {
  width: 200px;
  height: 100px;

  float: left;
  margin-left: -100%;

  position: relative;
  left: -200px;
}

.right {
  width: 200px;
  height: 100px;

  float: left;
  margin-left: -200px;

  position: relative;
  left: 200px;
}

.center {
  width: 100%;
  height: 400px;

  float: left;
}
```

### 三列等高布局

```html
<div class="container">
  <div class="item left"></div>
  <div class="item middle"></div>
  <div class="item right"></div>
</div>
```

```css
//1
.container {
  display: flex;

  /* By Default */
  /* align-items: stretch; */
}

.item {
  width: 500px;
}
```

```css
//2
.item {
  display: table-cell;
}
```

```css
//3
.container {
  overflow: hidden;
}

.item {
  float: left;

  margin-bottom: -100vh;
  padding-bottom: 100vh;
}
```

## Flex:1 的三个属性

`flex:1` 等价于

```css
flex-grow: 1;
flex-shrink: 1;
flex-basis: 0%;
```

\- flex-grow: 元素在有多余空间时的放大比例

\- flex-shrink: 元素在不足空间时的缩小比例

\- flex-basis : 缩小和放大的边界尺寸 如当值为`25%`，缩小时元素的宽度会小于等于父元素的 25%，放大时会大于等于父元素的 25%

##  Justify/align 的三种属性

## rem em px 的区别

- px 是绝对单位，是参照用户显示器的分辨率的单位，因此在用户放大页面时不会随之放大
- em 是相对于自己或父元素的字体大小，若自己没设定字体大小则会继承父元素的字体大小
- rem 和 em 类似 但它相对的是根元素的字体大小



## 定位属性

- `static` 默认值，元素按默认形式进行排列

- `relative` 半脱离文档流，可使用 `top` `left` 等进行相对于原位置的移动，不会影响到其它原素的排布

- `absolute` 完全脱离文档流，其它兄弟元素会完全完全忽略其存进行重新排布。它的定位相对于最近一个定位为非`static`的父级元素

- `fixed` 完全脱离文档流，相对于浏览器`view-port`定位，所以滚动对其无影响

- `sticky` 在可视范围之内，它会表现为`relative`的属性；元素部分或全部滚出`view-port`会表现为`fixed`

## 伪元素 伪类

## CSS 盒模型

`box-sizing`

HTML 元素均用盒模型进行定位和尺寸定义，它由外到内包含了 `margin ` `border` `padding` `content`

两者的区别在于`content` 也就是内容范围的定义：

- W3C 标准的`content-box`以实际内容作为 content 部分

- IE 标准的`border-box` 内容部分为 content + padding + border

同时这也影响了`width`和`height`的定义 === content / border



## CSS 选择器的优先级

最高优先级 `！important` 其无视选择器权重，若相同再比较权重

其余的选择器的权重可用数字量化表示

1000 行内样式

100 ID

10 类名 属性 伪类

1 标签名 伪元素

0 通配符 关系型

## z-index 的规则

由底到顶：

`background`

`zIndex < 0`

非定位块元素

浮动元素

非定位行内元素

定位元素

`zIndex > 0`

## 使用 CSS 画一个三角形

```css
.triangle {
  width: 0;
  height: 0;

  border-top: 10px solid red;

  border-bottom: 10px solid transparent;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
}
```

## 截断字符串，以...结尾

单行

```css
.truncate {
  width: 500px;

  /*实现关键*/
  text-overflow: ellipsis;
  overflow: hidden;

  /*强制它 不换行*/
  white-space: nowrap;
}
```

多行

```css
.truncate-multi {
  width: 500px;

  /*关键*/
  text-overflow: ellipsis;
  overflow: hidden;

  /*借用webkit外部属性实现*/
  display: -webkit-box;

  /*规定行高为三行*/
  -webkit-line-clamp: 3;

  -webkit-box-orient: vertical;
}
```

## 若不兼容 如何实现`sticky`

用 JavaScript 监听目标元素的顶部高度，在滚动时获取，若超出则把`postion`设为`fixed`

## 如何实现轮播图（CSS 和 jS 方式）

```css
@keyframes scroll {
  0%,
  15% {
    transform: translateX(0%);
  }
  20%,
  35% {
    transform: translateX(-20%);
  }
  40%,
  55% {
    transform: translateX(-40%);
  }
  60%,
  75% {
    transform: translateX(-60%);
  }
  80%,
  100% {
    transform: translateX(-80%);
  }
}

.images {
  width: 500vw;
  overflow: hidden;
  animation: scroll ease-in-out 15s infinite;
}

.item {
  width: 100vw;
  height: 300px;
  float: left;
}
```

JS:

`setInterval()` + 计算 transform 的值，和 CSS 的方法类似

## `margin`重叠的规则

正正取最正

负负取最负

正负 = 正值 - 绝对值大的值



# JavaScript

## 类型

### 引用类型、基本类型

**基本数据类型：**

- `number`
- `string`
- `boolean`
- `null`
- `undefined`
- `Symbol`
- `bitInt`

**引用数据类型：**

- `Object`
- 所有继承自`Object`的类型，如`Array`，`Function`，`Date`等

基本数据类型存放在内存中的栈区，内存空间是固定的，在复制的时候和函数传递的时候会采取传值的方式。(Immutable)

而引用数据类型是在栈空间中存入的不是对象本身，而是对应在堆内存的地址，实际的对象存放在堆内存之中。当对对象进行浅拷贝或参数传递之时，它传递的只是一个内存地址，而不是对像的数据本身。

#### Symbol

能在 JS 中创建 **独一无二**的值，`Symbol`本身是一个工厂函数，即使传入的值一样，生成的 Symbol 也不一样。

用法：

```javascript
const sym = Symbol('id');
```

使用情况：

- 消除 **Magic String**，有点像 TypeScript 中的 Enum 类
- 模拟私有的方法，使用 Symbol 作为`key`



## 判断类型

### 判断数组

`Array.isArray(arr)`

`arr instanceOf Array`

`arr.__proto__ === Array.prototype`

`arr.__proto__.constructor  = Array`

`Object.prototype.toString.call(arr) === '[object Array]'`

### 判断数据类型

- 方法 1 使用 typeof

```javascript
typeof undefined === undefined;
typeof 22 === 'number';
typeof 'str' === 'string';
typeof NaN === 'number'

typeof [] === 'object'
typeof /^\w$/ === 'object'
typeof null === 'object'; //!!!
typeof () => {} === 'function'
```

- 方法 2 使用 instanceof

  `instanceof`会检查对象的构造方法的显式原型 --- `function Object() .prototype`是否在目标原型链之上

```javascript
22 instanceof Number === true;
'str' instanceof String === true;

22 instanceof Object === false;
new Number(22) instanceof Object === true;

[] instanceof Object === true;
undefined instanceof Object === false;
null instanceof Object === false;
```

- 方法 3 `Object.prototype.function function toString().call()`

```javascript
Object.prototype.function function toString().call(2) === '[object Number]';
Object.prototype.function function toString().call('str') === '[object String]';

Object.prototype.function function toString().call([1, 2, 3]) === '[object Array]';
Object.prototype.function function toString().call({}) === '[object Object]';
Object.prototype.function function toString().call(() => {}) === '[object Function]';

Object.prototype.function function toString().call(null) === '[object Null]';
Object.prototype.function function toString().call(undefined) === '[object Undefined]';

Object.prototype.function function toString().call(Math) === '[object Math]';
Object.prototype.function function toString().call(new Date()) === '[object Date]';
```



## 类型转换

#### `==` 和 `===`的区别

- 使用`==`的时候，若等号两遍的值不同，会先进行类型的转换
  - `null == undefined // true`
  - `null / undefined == <anything> // false`
  - 两边都是基础类型 先转化为数字再比较
  - 对象和基础类型 先试`  valueOf()` 再试`  toString()`
- `===` 先比较类型再比值

```javascript
//They are all true!
!([] == false[1]);

const a = { x: 1 };
const b = { x: 1 };

a !== b;
a != b;
a == '[object Object]'; //toString()

const arr1 = [1];
const arr2 = [1];
arr1 !== arr2;
arr1 != arr2;

arr1 == '1'; // valueOf()
```

## ES6

### ES6 的新特性

- `let ` `const`
- `class`
- `=>`
- `Map,Set,WeakMap,WeakSet`
- `Promise`
- Template String
- 数组对象的解构
- 扩展运算符
- `for...in` / `for...of`

### `let` , `const` 和`var`

使用`var`定义的变量，它自动会在所在的代码生成阶段，执行上下文被创建之时定义为`undefined`,并被加入其变量环境中，因此它可以在代码定义之前访问，也就是我们所说的变量提升；

使用`let` 和 `const ` 定义的变量，它在创建执行上下文的阶段会被认为是`uninitialized`的，会被加入语义环境之中

 因此不可以在代码中定义之前访问它，也就是`let` 和`const`不会变量提升

`let`的值可以之后进行重新赋值 `cosnt` 不可以



不使用变量关键字命名的变量，会被挂在全局`globalThis`上，在浏览器它指`window`, nodejs指`global`

### Promise

Promise 是 ES6 提供的一个实现异步操作的非常好的解决方案，它解决了 ES6 之前使用回调函数的一些弊端：比如说如果有多个异步操作有依顺序进行，那么它的实现会有很多回调函数的嵌套，也就是所谓的`callback hell`. 同时对于错误也非常的难以调试。

而 Promise 使用链式语法，同时附带了`catch`方法，解决了上述问题。

#### Promise 方法

- `Promise.all()`

```javascript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const result = [];

    for (let index = 0; index < promises.length; index++) {
      const promise = promises[index];

      if (!(promise instanceof Promise)) {
        result[index] = promise;
        continue;
      }

      promise
        .then((value) => {
          result[index] = value;

          //Wait...
          if (result.length === promises.length) {
            resolve(result);
          }
        })
        .catch((error) => reject(error));
    }
  });
}
```

- `Promise.allSettled()`
- `Promise.race()`
- `Promise.any()`

### 箭头函数

- 没有自已的`this`，若在其中出现`this`,会指向外部环境中的`this`

- 没有`argument`,若要得到全部参数则要用`...args`获取

- `this`和外部语义环境绑定，因此不可使用 `apply` 和 `call`去改变，`bind`对其无效

- 不能作为构造函数使用

  

## 手撕题

### 深拷贝和浅拷贝

- 深拷贝在内存另外开辟一块内存空间，它们之间的值互相不受影响

- 浅拷贝出来的对像在内存中指向同一个内存空间，它们的值一个修改了，另一个也会跟着变化

  实现

  - 1. 判断是否为对象
    2. 判断是否为数组
    3. 判断是否为函数
    4. 循环引用， 利用 set 解决

  ```javascript
  function deepClone(target,set = new WeakSet()){
    let result;
  
    //Prevent ciruclar reference...
    if(set.has(target)) return target;
  
    if(Object.prototype.toString().call(target) === '[object Object]') result = {};
    else if (Array.isArray(target)) result = [];
    else return target;
  
    for(let key in target){
      //Record
      set.add(target[key]);
  
      if(target.hasOwnProperty(key)){
        //Object OR Array
        if(typeof target[key] === 'object'){
            result[key] = deepClone(target[key],set);
          }
  				//Function
        }else if(typeof target[key] === 'function'){
            result[key] = target[key].bind(result)
        }else {
          //Primitive
          result[key] = target[key]
        }
      }
    }
  
    return result;
  }
  ```

### 防抖和节流

- **防抖**：对于一些动作造成的后果比较昂贵之时，希望待其用户操作确定（稳定）之后再处理结果。在这一段时间内若多次触发，定时器会重置。

  - 应用场景： 提交按钮的多次点击； 用户搜索框的输入

  - 手写实现：

    ```javascript
    //Always delay a couple of seconds...
    function debounce(fn, time) {
      let timer = null;
    
      return function (...args) {
        const context = this;
    
        if (timer) {
          // clear timer...
          clearInterval(timer);
        }
    
        //set or reset timer...
        timer = setInterval(() => {
          //setInterval 在不同的环境下运行，this指向global,因此利用闭包方式传入this
          fn.apply(context, args);
    
          timer = null;
        }, time);
      };
    }
    
    //Invoke immediately...
    function debounce(fn, time) {
      let timer = null;
      let invoked = false;
    
      return function (...args) {
        const context = this;
    
        if (!invoked) {
          invoked = true;
          return fn.apply(context, args);
        }
        if (timer) {
          // clear timer...
          clearInterval(timer);
        }
    
        //set or reset timer...
        timer = setInterval(() => {
          //setInterval 在不同的环境下运行，this指向global,因此利用闭包方式传入this
          fn.apply(context, args);
    
          timer = null;
          invoked = false;
        }, time);
      };
    }
    ```

- **节流**：对于一些频繁触发的动作，用定时器限制其最小触发间隔，以避免过于频繁去触发。在这一段时间内若多次触发，只会有一次生效。

  - 应用场景：滚动事件，缩放事件，Resize 事件

  - 手写实现：

    ```javascript
    function throttle(fn, time) {
      let inThrottle = false;
    
      return function (...args) {
        const context = this;
    
        if (!inThrottle) {
          // setTimeout 的this 指向会改变，利用闭包传入
          setTimeout(() => {
            fn.apply(context, args);
            inThrottle = false;
          }, time);
    
          inThrottle = true;
        }
      };
    }
    ```

### 链式调用

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.eat = function () {
  //code here...

  return this;
};

Person.prototype.sleep = function () {
  //code here...

  return this;
};
```

### Curry 化

```javascript
function sum(...args) {
  const nextFunc = (...nextArgs) => sum(...args, ...nextArgs);

  nextFunc.getValue = () => args.reduce((a, b) => a + b);

  return nextFunc;
}
```

### `call`,`bind`,`apply` 

```javascript
Function.prototype.myCall = function (context, ...args) {
  //Browser => window ; Node.js => global; 它们有统一的接口globalThis
  const _context = context || globalThis;

  _context.fnToCall = this;

  const result = _context.fnToCall(...args);

  delete _context.fnToCall;

  return result;
};

Function.prototype.myApply = function (context, args) {
  const _context = context || globalThis;

  _context.fnToCall = this;

  const result = _context.fnToCall(args);

  delete _context.fnToCall;

  return result;
};

Function.prototype.myBind = function (context, ...args) {
  const _context = context || globalThis;

  _context.fnToCall = this;

  const returnFunc = function () {
    return _context.fnToCall(...args);
  };

  delete _context.fnToCall;

  return returnFunc;
};
```



### 手写Promise

```javascript
const Status = {
    PENDING: 'pending',
    FULFILLED: 'fulfilled',
    REJECTED: 'rejected',
  };

class MyPromise {
    status = Status.PENDING;
    value = undefined;
    error = undefined;
    onFulfilledCallbacks = [];
    onRejectedCallbacks = [];

		constructor() (executor) {
      let self = this;

      function onResolve(value) {
        self.value = value;
        self.status = Status.FULFILLED;

        if (self.onFulfilledCallbacks.length) {
          self.onFulfilledCallbacks.forEach((fn) => fn(value));
        }
      }

      function onReject(reason) {
        self.error = new Error(reason);
        self.status = Status.REJECTED;

        if (self.onFulfilledCallbacks.length) {
          self.onRejectedCallbacks.forEach((fn) => fn(self.error));
        }
      }

      executor(onResolve, onReject);
    }

    then(onFulfilled) {
      if (this.status === Status.FULFILLED) {
        onFulfilled(this.value);
      } else if (this.status === Status.PENDING) {
        this.onFulfilledCallbacks.push(onFulfilled);
      }
    }

    catch(onError) {
       if (this.status === Status.REJECTED) {
        onReject(this.reason);
      } else if (this.status === Status.PENDING) {
        this.onRejectedCallbacks.push(onError);
      }
    }
  }
```





## 编译，运行环境

### 闭包

当一个函数返回的函数可以访问到当前生成该函数作用域中的变量时，即使在生成函数执行完毕之后，它引用的变量不会因它所在的执行上下文的出栈而被回收，而是被保存在一个封闭的内存区域之内，且只有这些返回函数能访问。这个封闭的区域为之闭包。

使用场景：

- 防抖与节流等使用`decorator`形式的函数

- 回调函数 -> 事件点击 / 异步回调

- `setTimeout()`等要包含变量的情况

### 编译和执行过程

JavaScript 的代码运行分为**编译**和**执行**过程

在编译阶段，会做以下的几件事：

1. 变量环境的创建
2. 语法环境的创建
3. `this`的绑定
4. 创建外部环境的指引

变量环境创建时会检查当前作用域内的使用`var`关键字定义的变量和`function`关键字定义的函数，并为它们赋上初值。`var`变量初值是`undefined`

`function`的初值是函数本身，这也就是 JavaScript 中的 `var` 和`function`出现变量提升现象，且`function`比`var`优先定义的原因。

语法环境的创建主要涉及到`let`和`const`定义的变量，在这个过程中，JavaScript 会找到这些变量，但会认为它们是未定义的状态，不可提前访问。直到开始运行到声明语句之时，在这之前的区域也叫作 **暂时性死区** 这就是使用`let`和`const`定义的变量不能是升的原因。

这四步加起来共同构成了 JavaScript 的执行上下文

执行时，所在作用域会经历上述阶段，生成执行上下文，并把其推入执行栈之中。在当前作用域已运行完毕，该执行上下文会被推出执行栈，等待回收。闭包情况除外。

### `this`

因 JavaScript 的函数可以作为返回值，使得函数可在任意环境下执行。因此，`this`的指向也会随函数运行的位置，准确地来说是执行的上下文而改变。执行的上下文不同，`this`的指向也不同。

- 函数中的`this`
  - 由对象调用的函数 => 指向调用对象
  - 无对象调用的函数 => 指向`global`对象 / `undefined`（严格模式下）
  - 作为构造方法调用 => 指向使用`new`关键字生成的对象
- 由`bind`,`call`,`apply`调用，改变`this`的指向
- 箭头函数中的`this`
  - 箭头函数没有`this`，如若在箭头函数中出现`this`，则会从它的外部执行环境中获取。

## 模块化

### 前世

主要存在的模块系统有 **commonjs**,**AMD**,**UMD**,**ESModule**

在初期的 JavaScript 并没有模块化的概念，JavaScript 仅存在于浏览器中，用`<script>`引用。

要注意加载的先后顺序，对于大型项目来说管理非常麻烦。

在 ES6 之前是没有模块系统，也没有封闭作用域的概念的，所以上面 js 文件里申明的变量都会存在于全局作用域中。

因此，为了解决这个方法，那时的开发者会使用命名空间的方法，或是利用JavaScript的闭包特性，利用立即执行函数来做变量的封闭；



但开发者之间都没有一个统一的标准，`Node.js`为了改善这一点开发出了`commonjs`的模组化系统。

### CommonJS

它定义了：**每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。**



它利用**`module` 代表当前模块，是一个对象，保存了当前模块的信息。**

**`exports` 是 `module` 上的一个属性，保存了当前模块要导出的接口或者变量，**

**使用 `require` 加载的某个模块获取到的值就是对应模块使用 `exports` 导出的值**

`require` 命令的基本功能是，读入并执行一个 js 文件，然后返回该模块的 exports 对象

它的加载均是同步加载，因文件在本地磁盘，加载很快。



但在浏览器中绝大部分的资源均是网络加载，因些更适合用异步加载的方案。



### AMD模组（Asynchronized Module Defination）

RequireJS 是一个 js 文件和模块加载器。它非常适合在浏览器中使用，但它也可以用在其他 js 环境

在推广之下它就逐渐成了一种规范，也就是AMD模组规范

由`RequireJS`实现的，本质上是利用一个回调函数，在模组加载之后会执行相应的回调函数，所有依赖于这个模块的代码都会放在这个回调函数之中，但没有解决文件依赖次序的问题



### CMD (Common Module Definition)

CMD模组规范是由一个名为`Sea.js`的模组加载库推广的，它的开发都认为，AMD 规范是异步的，模块的组织形式不够自然和直观。于是CMD在追求能像 CommonJS 那样的书写形式。于是就有了 CMD 。也就是说 在CMD的规范之下，可以使用`require()`,`module.export`等等

它的原理是：加载后未执行前 对这个模块中利用到`require`的进行依赖检测，去提取和加载依赖项，再执行回调，这样既能在浏览器中使用commonjs的语法，也能异步加载模块



### ESModule

而上述所有的模组解决方案，都有一个共同点，就是运行时检查依赖，在代码实际运行之时才去检查模组依赖，

而ES6 Module 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及导入和导出的变量，也就是所谓的"编译时加载"。

因此，我们在使用ES模组的时候，一般不是使用表达式/变量的形式，而是在文件的顶部使用`import`语句；

ES6比Commonjs等模组系统多了一个编译时解析的过程，能提前通过`import`和`export`语句来找到对应的依赖关系。

这时，它只是发现了模组的一个引用关系，这种关系是只读的，在真正执行的时候如果要用相关的模组，就会到被加载的模块中去取值。



而Commonjs它输出的值是一个对象，它的值是对应值的拷贝，所以一但输出，模组内再变化是不会影响到模组外的值的。





## 事件循环

JavaScript 的任务分为两种，分别为同步和异步。同步任务会依次在主线程运行，而异步任务会被存在任务队列中等待合适的时机移到执行栈中运行。之所以有这样的设计因为 JavaScript 主线程只有一个，不可以把它阻塞。

每当执行栈被清空，JavaScript 会检查有无没完成的且时机合适的异步任务，有的话会把它放入执行栈继续运行，这样不断循环下去。这就是所谓的事件循环。

异步的事件分为宏任务和微任务

宏任务要直接放入执行栈运行的任务：像**主代码的运行**，`setTimeout(),setInterval()`， **渲染 UI**等均是宏任务，

而微任务主要是存放宏任务带来的影响，比如`Promise`之中的`then`等的回调函数，微任务是宏任务造成的影响具有实时性，所以较为重要，要优先执行。

- **Browser** 环境下的事件循环

  在 Browser 之中，JS 会一次把一个宏任务从队列中拿出来，执行完之后会执行微任务中的所有任务；之后再进行下一次的循环

- 在 **Node** 环境下

  事件循环的机制不相同，Node.js 会把宏任务再细分，分成四大队列，每次处理`1 ~ 多`个任务：

  `Timer` ：处理`setTimeout()` 和`setInterval（）`

  `I/O`:处理使用`fs`等输入输出的任务

  `check`:处理`setImmediate()`

  `CloseCallback`:处理一些关闭事件

  微任务细分：

  `process.nextTick()` (先)

  `.then(() => {})` （后）

  NodeJs 和 Browser 最大的不同，它会在适当的时机停下等待，直到有新的任务完成。



#### `requestAnimationFrame()`

- 解决的问题：

  传统的 CSS 动画在`requestAnimationFrame`出现之前，一般会使用`setTimeout`和`setInterval`两者，每隔一段时间进行一些元素的刷新。这种方法的缺点在于：

  `setTimeout`和`setInterval`是不精确的，它们的间隔时间会大于或等于所设定的时间，它们会被依次放入任务队列中的宏任务队列，排队进行。如果遇到阻塞，则会一直等待；

  在动画元素不可见之时，不会自动停止，因而会耗费大量资源；

- 特点和优势：

  1. `requestAnimationFrame`没有一个固定的时间间隔，最佳更新时间由浏览器分配。当当前条件充许进行下一次重绘/回流时，`requestAnimationFrame`中的回调会被调用
  2. 对于不可见的元素（滚出 view-port / 背景标签页）时，`requestAnimationFrame`的调用会停止或被降至很低，以降低系统资源消耗
  3. 会把所有操作聚合，尽量在一次重绘或回流就完成

## 原型 继承

### 原型系统

原型是 JavaScript 的继承系统，属于父类型的方法和属性可以被子类型的对象所引用。每个 JavaScript 创建的对象都有一个隐式原型属性`__proto__`，它指向了生成这个实例的构造函数的原型`prototype`，也被称作显式原型，所有指向它的对象都可以访问到显式原型的方法。而原型本身也是对象，也有自己的原型，这样就型成了一种链式的继承。

相比于其它的编程语言，使用原型的好处是：

- 同类型的对象引用的是同一个原型对象，这样就减少了内存空间，否则需要每创建一个对像就产生众多的父类对象

- 改变父类对像也非常简单，只要改变指向原型的指针即可

  

### `new` 一个对象的时候发生了什么？

1. 新建一个空的对象 `{}`

   ```javascript
   const person = {};
   ```

2. 使得`this`指向这个新建的对象

3. 将这个对象的隐式原型指向构造函数的显式原型

4. 以新对象作为上下文运行构造方法

   ```javascript
   person.__proto__ = Person.prototype;
   Person.call(person, ...args);
   ```

5. 返回这个对象

   ```javascript
   // 如若Person 构造方法返回了别的对象，则优先采用
   const highPriorityPerson = Person.call(person, ...args);
   if (highPriorityPerson) return highPriorityPerson;
   
   //否则采用最先创建的对象
   return person;
   ```

### 用多种方法实现继承

- 方法 1 调用构造函数继承

```javascript
function Animal(age) {
  this.age = age;
}

function Human(name, age) {
  Animal.call(this, age);

  this.name = name;
}

const human = new Human('Tony', 20);
/*
{
	name:'Tony',
	age:20,
	[object Object]:{
		function Object() :function Human(name,age){...},
		[object Object]: Object {...}
	}
}
*/
```

- 方法 2 **组合继承**

```javascript
function Animal(age) {
  this.age = age;
}

Animal.prototype.breath = function () {
  console.log('breathing...');
};

function Human(name) {
  this.name = name;
}

Human.prototype = new Animal(20);
Human.prototype.function Object()  = Human;

const human = new Human('Tony');

/*
{
	name:'Tony',
	[object Object]:{
		age:20,
		[object Object]:{
			breath:function(){...},
			function Object() { [object Object] }:function Animal(age){...}
			[object Object]: Object {...}
		}
	}
}
*/
```

- 方法 3 **寄生式继承**

```javascript
function createAnimal(proto) {
  function Dummy() {}
  Dummy.prototype = proto;
  Dummy.prototype.breath = function () {
    console.log('breathing...');
  };

  return new Dummy();
}

function createHuman(age, name) {
  const animal = createAnimal({ age, name });
  animal.walk = function () {
    console.log('walk');
  };

  return animal;
}
```

- 方法 4 组合寄生式

```javascript
function createObject(proto) {
  function Dummy() {}
  Dummy.prototype = proto;

  return new Dummy();
}

function inherit(Child, Parent) {
  const parentInstance = createObject(Parent.prototype);
  parentInstance.constructor = Child;
  Child.prototype = parentInstance;
}

function Animal(age) {
  this.age = age;
}

Animal.prototype.breath = function () {
  console.log('breathing...');
};

function Human(name, age) {
  Animal.call(this, age);
  this.name = name;
}

inherit(Human, Animal);

Human.prototype.talk = function () {
  console.log('Talking...');
};

const human = new Human('Tony', 20);

/*
{
	age:20, 																				//human
	name:"Tony",
	__proto__:{																			//Human.prototype
		function Object() : function Human(name,age){...},
		talk:function(){...},
		__proto__:{
			breath:function(){...},
			function Object() : function Animal(age){...},
			__proto__: Object {}...
		}
	}
}
*/
```

## API

#### 27. JavaScript 的数组方法

```typescript
type forEach<T> = (fn: (item: T, index: number, arr: T[]) => void, thisArgs: any) => T[];
type map<T, N> = (fn: (item: T, index: number, arr: T[]) => R, thisArgs: any) => N[];
type filter<T> = (fn: (item: T, index: number, arr: T[]) => boolean, thisArgs: any) => T[];
type reduce<T, R> = (fn: (previous: R, current: T, index: number, arr: T[]) => R, initValue: R) => R;

type find<T> = (fn: (target: T, index: number, arr: T[]) => boolean, thisArgs: any) => T;
type findIndex<T> = (fn: (target: T, index: number, arr: T[]) => boolean, thisArgs: any) => number;

type some<T> = (fn: (item: T, index: number, arr: T[]) => boolean, thisArgs: any) => boolean;
type every<T> = (fn: (item: T, index: number, arr: T[]) => boolean, thisArgs: any) => boolean;

type concat<T> = (...arrays: T[]) => T[];

type slice<T> = (start: number, end?: number) => T[];

//以下所有方法均在原数组的基础上修改
type splice<T> = (start: number, deleteCount?: number, ...newItems: T[]) => T[]; //被删除的

//依ASCII顺序比较
type sort<T> = (compareFn: (a: T, b: T) => number) => T[];

//返回数组的新长度，下同
type push<T> = (...newValue: T[]) => number;
type pop<T> = () => T;

type unshift<T> = (...newValue: T[]) => number;
type shift<T> = () => T;

type reverse<T> = () => T[];
```

### 30. `Set` `Map` `WeakSet` 和`WeakMap`四者的区别和用处

`Set`和`WeakSet`用于存放一系列不相同的值；

`Map`和`WeakMap`用于存放一系列不相同的键值对；

`Set`可以存放任何类型的值，包括基本类型和引用类型；有遍历方法；

`WeakSet`只能存放引用对象，不可存放值；当`WeakSet`中的值无处引用时，可被垃圾回收，不容易造成内存泄漏；`WeakSet`是不可遍历的

`WeakMap`和`WeakSet`类似，其键必须是引用类型的值

- 不可遍历的原因：`WeakSet`和`WeakMap`运行前后的成员数量可能不同（被回收），因此不存在遍历机制

## DOM 事件

#### 32. DOM 的事件机制/ 事件流？

一个完整的事件流分为**捕获阶段**，**目标阶段**，**冒泡阶段**

- 捕获阶段：在 W3C 的规定中，事件由 window 开始向下发布，按以下顺序向下传播：

  `window` => `document` => `<html>` =>`<body>` => ... => 一直下沉到真正发生所在的元素

  在这个阶段，会调用沿途元素相应事件的捕捉函数（如果有给定）

- 目标阶段：事件下沉到目标元素的时刻

- 冒泡阶段：事件会从发生目标开始，由下至上逐层向上传递，触发相应的事件处理函数

- 事件目标：

  - `event.target` 真正被点击的目标，在全过程中均有且仅有一个
  - `event.currentTarget`目前正在运行处理函数的元素，随事件流变化，事件完成冒泡后会成为`null`

- 应用场景和相关方法：

  - `event.preventDefault`

    阻止 HTML 元素的一些默认行为，如：

    - 表单中的提交按钮
    - `<a>`中的默认跳转行为

  - `event.stopPropagation`

    阻止事件进一步下沉或冒泡

  - `event.stopImmediatePropagation`

    阻止事件进一步下沉或冒泡，且停止其它的事件继续处理

#### 33. 事件委托

利用事件冒泡机制，将一系列元素的处理逻辑统一交予父元素代为执行事件。

```
div
 |_ ul（处理）
 		|_ li - div
 		|_ li - div
 		|_ li - div (触发)
 		|_ li - div
 		|_ li - div

```

可以此法减少事件处理函数的数量，也能减少 DOM 操作的数量，提高性能



## 多线程

Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。



在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。

等到 Worker 线程完成计算任务，再把结果返回给主线程。

这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程不会被阻塞或拖慢。


特点：

- webworker无法访问DOM节点
- 无法访问全局变量或者函数
- webworker与主线程之间不能共享资源和作用域
- 不支持跨域
- 适用于计算量较大的情况
- global对象的指向有变更。Window类型的window对象被DedicatedWorkerGlobalScope类型的self对象所取代。即，我们一般用的window需要改写成self。
- 只能访问部分navigator对象内的数据。
- 内置了importScripts函数，代替了DOM中的script标签引用脚本机制







通信：

Worker和主线程之间通过异步事件在线程之间传递消息。

主线程分别监听了message事件和error事件，用来处理接收到Worker传出来的数据以及错误信息

`worker.postMessage();` 向外广播消息



```react
//index.html
<script>
  var myWorker = new Worker("my_task.js");

  myWorker.addEventListener("message", function (oEvent) {
    console.log("Called back by the worker!\n");
  }, false);

  myWorker.postMessage(""); // start the worker.
</script>

//worker.js
postMessage("I\'m working before postMessage(\'ali\').");

onmessage = function (oEvent) {
  postMessage("Hi " + oEvent.data);
};
```



## 回收机制

两种策略：

1. 标记清除

   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记；再去掉能被访问到的变量，那么其余的就是可被回收的变量了

2. 引用计数

   生成一个变量，它是一个引用类型时，可以为引用的值计数，来计算被引用的次数。每有一个引用它的变量就加1，引用它的变量指向了别的变量就减1，直到引用次数为0，那就可以被清除







# TypeScript

## TS的意义

## interface 和 type



# React

## **理念**

1. **React是多个库的集合**。

> React is a JavaScript library for building user interfaces.

React这个库的目的，是提供书写UI的一种方式 —— (JS对象 / JSX + 转译工具 )，以及提供一种管理UI状态的接口（Hooks及其它API）。

它与React-Reconciler的结合使用，就实现了React的最根本目的 —— 快速地创建一系列和真实的UI有著一一对应的关系JavaScript对象。



它的输入是变化后的JSX对象，输出是代表UI节点的JavaScript对象。在React 16.8之后的语境来说，这些对象就Fiber节点。



而把Fiber渲染到真实的UI树上的工作，则交由各自平台的渲染器来实现。在浏览器环境之下，则是`React-DOM`，React Native环境之下，则是`react-native`。但本质上，React的渲染目标不一定是UI，可以是任何具有树状结构的视图，因此，也有`React-Pixi` `React-Three` 这样的库。它们的渲染目标可能是底层的对象，如Three.js 对象。



因此，这也就是我们要把 React 的核心分为许多的库，如挂载DOM的React-DOM，负责调度的Scheduler，负责调和的React-Reconciler。React允许我们可以根据不同的使用场境，分别去实现这些库。



2. **React的设计理念和核心出发点：快速响应变化**

现代JavaScript框架的瓶颈：

- CPU 瓶颈 

  主流浏览器的刷新频率为60Hz，每秒刷新60次，因此，在16.6ms需完成一次页面的刷新。而在这16.6ms之中，需要完成以下的工作：

  > JS脚本执行 ==> 布局的计算 ==> 样式的绘制 

  

  而渲染节点数量过多 => 渲染时间超过 16.6ms  => 浏览器没有时间进行布局、样式的计算和绘制 => 页面掉帧

  

  造成这程情况核心原因是：浏览器**渲染线程**和**JS脚本线程**是互斥的，它们不可能同时操作一个DOM，必定要等到任一方完成。



因此 React为解决这个问题，为UI渲染引入时间分片，它的目的，是把React的同步更新，变成异步可中断的更新。

在JS执行的过程中，每帧默认预留 5ms 的时间给浏览器进行布局的计算和样式的绘制。在JS执行要超过时间，React调度器会把当前JS的任务中断，把线程让出给浏览器，完成之后再接著执行之前的中断操作。

- I/O 瓶颈 

我们向服务端发送请求，到数据送回渲染成UI的这段时间，我们需要减少用户的感知等待的时间。

因此，React引入`<Suspense>` 功能，我们可以传入fallback组件，比如说骨架屏。

而在此其间，我们也希望我们的应用是可响应的。

而这也需要我们把更新中断或跳过，实现异步更新。



本质上来讲，React的优化理念，即是把**同步更新变成异步可中断的更新**。



## 架构

### React 新老架构对比

React15 架构，分为：Stack Reconciler + Renderer

React16 架构，分为：Fiber Reconciler + Scheduler + Renderer



React15 采用的是Stack Reconciler， 即利用JavaScript本身的递归栈进行调和更新。而这个过程是没有办法进行人为的打断再恢复。因此，如果更新的节点很多，超过了16.6ms的更新，那么下一次的更新必须等到之前的更新计算 + 重绘完成后再进行。在等待更新的过程中，用户是没有办法对视图作出操作的，因为高优更新没法打断当前正在进行的调和操作。



为了改善这个情况，React16 把调和过程完整重构，引入了Fiber Reconciler 和 Scheduler。

**Scheduler （调度器）** ，实现了浏览器在有空余时间时调度某些任务的能力。它和浏览器原生API`requestIdleCallback` 十分相似，即在重绘、重排之后调用某些注册的函数回调。

但`requestIdleCallback`的调用时机不由React操控，因此React没有利用这个浏览器提供的API，而是自己利用宏任务实现的类似的功能，并加上了React优先级调度的相关功能。



### Fiber 架构

**什么是Fiber？**

从数据结构层面，Fiber是连接开发者书写的JSX对象和实际UI组件的连接者，并附加了动态更新时该组件的属性。在Fiber的数据结构中，有以下的属性：



```typescript
//react/packages/react-reconciler/src/ReactFiber.old.js
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // 实例属性
  this.tag = tag; 				  // React 内部表示节点类型，如HostComponent FunctionComponent...
  this.key = key;
  this.elementType = null;	// elementType 和 type 类似，表示具体类型，如 ”div“ ”span“ App() 等
  this.type = null;
    
  this.stateNode = null;   // 真实UI对象

  // Fiber 架构属性
  this.return = null; 		 // 父级 Fiber 节点 
  this.child = null; 		 	 // 第一个子 Fiber 节点
  this.sibling = null;		 // 相邻的第一个 Fiber 节点
  this.index = 0;					 // 当前节点在 children 列表中排第几 在reconcileChildrenArray 有用

  this.ref = null;

  this.pendingProps = pendingProps; 	// 当前输入的 props
  this.memoizedProps = null;					// 上一次更新的 props
  this.updateQueue = null;						// updatePayload 数组 表示更新的属性 ['title','new']
  this.memoizedState = null; 	   // FunctionComponent 保存的Hook 链表
  this.dependencies = null;

  this.mode = mode; //ConcurrentMode | LegacyMode......

  // Effects 副作用相关
  this.flags = NoFlags; 
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  // 优先级调度相关
  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  //双缓存树的另一对应Fiber
  this.alternate = null;
    
  //.....
 }
```



**Fiber和Fiber之间形成的关系：**

1. 当前节点和下一个子Fiber节点通过 `child`  相连
2. 当前节点和下一个兄弟节点通过 `silbing` 相连
3. 父子节点之间通过 `return`  指针相连

所有的Fiber之间相互连接成多向的链表结构，来模拟UI的树状结构。



**Fiber树之间的双缓存机制：**

在整个 React 应用运行的期间，内存中会存在两棵 Fiber 树，一棵代表**当前视图**中的 Fiber 树，称作 `current` FiberTree, 一棵代表**构建中**的Fiber树，称作 `workInProgress` FiberTree。两棵 Fiber 树由一个 Fiber 结点来统一管理，它是整个应用的根节点，称作 `FiberRootNode`。

`FiberRootNode`有一个特殊的属性——`current`，会一直指向当前视图中表示的 Fiber 树的根节点，也就代表了 `current`Fiber树。

在两棵树下的**每一个 Fiber 节点**，都有一个 `alternate` 属性，它互相指向另外一棵树对应的节点。

```js
currentFiber <= alternate => workInProgressFiber
```



在更新时，React 会重建 workInProgress Fiber 树；更新完成后，会把FiberRootNode的current指向新创建的workInProgress Fiber 树，即把当前视图的Fiber树指向处理好的Fiber树。

**为什么要实现这个双缓存的机制呢？**

1. 在渲染时，我们从根节点开始向下遍历所有的节点，来重建我们的 workInProgress Fiber树，若我们断定某个Fiber没有任何变化，那我们直接从 currentFiber，也就是从旧视图的Fiber树中直接复制节点，不再重新创建

2. 在更新到计算 workInProgress 完成之前有一定的时间差。我们希望保留上一次的视图，在内存中计算新视图，完成后一次性替换掉旧视图。

   好处：一是避免了中间状态向用户展示、二是减少了原生的UI操作（直接set innerHTML 和 逐次 dom.appendChild 的区别。）





## 渲染过程

### **Overview**

React从触发更新到视图呈现，经历了两个主要的阶段：

- **Render 阶段** 

  主要工作：

  1. 由根节点开始向下，深度优先遍历每一个Fiber节点，构建workInProgress Fiber树

  2. 在构建过程中，找出变化的节点，为它们打上对应的操作标记

  3. 把含有操作标记的 Fiber连接形成一条链表

     

- **Commit 阶段**

  主要工作：

  1. 对上述得到的含有操作标记的链表执行对应的DOM操作
  2. 执行副作用任务 （useEffect / useLayoutEffect）



### Render 阶段

Stack Reconciler的工作利用JS递归栈对所有的树状对象实现深度优先的遍历，而Fiber Reconciler为了模拟递归的工作，把这项工作分为两个主要部分——向下的**“递”** 和 向上的 **“归”**阶段。

而它们对应由两个函数构成——`beginWork` , `completeWork`。



假设我们有以下的组件：

```jsx
function App(){
  return (
    <div>
    	<header>
      	<img />
        <p>Edit <code>src/App.js</code>and save to reload.</p>
      	<a>Learn React</a>
      </header>
    </div>
  )
}
```

 在mount阶段，这两个函数的调用顺序将会是：（由上到下）

```typescript
function beginWork(current: Fiber,workInProgress: Fiber){}
function completeWork(current: Fiber,workInProgress: Fiber){}

//Mount 階段， 因没有视图，current会为null
beginWork(HostRoot,null) //tag:3 HostRoot
  |	beginWork(null,App()) //elementType: App()
  |		| beginWork(null,<div>)
  |   | 	| beginWork(null,<header>)
  |		|		|		|		beginWork(null,<img>)  //img沒有子節點 直接調用completeWork()          
  |   |   | 	|		completeWork(null,<img>)
  |   |   | 	|   	    
  |		|		|		|	  beginWork(null,<p>)
  |   |   | 	|   	|		                            
  |   |   | 	|   	|		beginWork(null,"Edit")
  |		|		|		| 		|		completeWork(null,"Edit")
  |		|		|		| 		|		 |
  |		|		|		| 		|		beginWork(null,<code>) //優化路徑            
  |   |   | 	|   	| 	completeWork(null,<code>)
  |		|		|		| 		|		 |              
  |   |   | 	|   	| 	beginWork(null,"and save to reload.")
  |		|		|		| 		|		completeWork(null,"and save to reload.")
  |		|		|		| 		|			
  |		|		|		|		completeWork(null,<p>)
  |		|		|		|	                               
  |   |   | 	| 	beginWork(null,<a>)                     
  |   |   | 	| 	completeWork(null,<a>)
  |		|		|		| 				                               
  |   |   | completeWork(null,<header>)   
  |   | completeWork(null,<div>)   
  |  completeWork(null,App())	
completeWork(HostRoot,UpdatedHostRoot) //tag:3   
```

可以看到，这两个函数的调用顺序和深度优先遍历的递归顺序是相同的。

上述的优化路径指：如果一个Fiber点，它只有唯一子节点，而且这个子节点为文本节点，如`<code>src/App.js</code>`,那么React不会为这个单独的文本节点再创建一个Fiber，而是直接把`<code>`和文本当作一整个Fiber处理，因此会直接进入`completeWork`。



#### beginWork 阶段

```typescript
function beginWork(current: Fiber, workInProgress: Fiber, renderLanes: Lanes) {...}
```

第一个参数是上一次Fiber树中对应的Fiber节点，第二个参数是当前更新中的Fiber树所对应的节点，第三个参数与优先级相关。



beginWork的工作：

1. 根据Fiber节点不同的`tag`,进入不同的更新处理：

   ```typescript
   switch (workInProgress.tag) {
       case FunctionComponent:
        	return updateFunctionComponent(...);
       
       case ClassComponent:
         return updateClassComponent(...);
   
       case HostRoot:
         return updateHostRoot(...);
   
       case HostComponent:
         return updateHostComponent$1(...);
   
       case HostText:
         return updateHostText$1(...);
   //......
   }
   ```

   

2. 对参数进行简单处理后，进入`reconcileChildren`函数。

   ```typescript
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   ```

   

   在此之前，如果是HostComponent，且命中了之前所讲的**单一文本子节点的优化路径**，那么会把`nextChildren`置空，之后对children 的调和就会被跳过。

   ```js
   var isDirectTextChild = shouldSetTextContent(type, nextProps);
   
     if (isDirectTextChild) {
       // We special case a direct text child of a host node. This is a common
       // case. We won't handle it as a reified child. We will instead handle
       // this in the host environment that also has access to this prop. That
       // avoids allocating another HostText fiber and traversing it.
       nextChildren = null;
     }
   ```



​		reconcileChildren会根据是在 **mount** 阶段 或是在 **update** 阶段进入不同的分支：

```typescript
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    //全新的 Fiber
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    //更新旧 Fiber
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }
}
```



这两个函数本质的来源是一个工廠函數 `ChildReconciler()`:

```typescript
var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {}
  function placeSingleChild(newFiber) {}
  //...其它方法
  
  
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes){
    //根據傳入的參數，判斷應用上述的方法
  }
  
  return reconcileChildFibers
}
```

工廠函數傳入的布爾值，指明了需不需要在reconcile之中追蹤副作用。在mount階段是特殊的更新階段，對副作用的處理比較特別，因此會傳入`false`。會跳過所有副作用tag的標記

如果是update的情況，reconcile時，會為對應的 Fiber 節點打上相應的EffectTag。

如刪除操作：

```typescript
function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }

    var deletions = returnFiber.deletions;

    if (deletions === null) {
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion; // 打上刪除操作的標記
    } else {
      deletions.push(childToDelete);
    }
}
```

Fiber中的操作標記，以24位二進制數表示

```js
const NoFlags = /*                      */ 0b0000000000000000000000000;
const PerformedWork = /*                */ 0b0000000000000000000000001;

// You can change the rest (and add more).
const Placement = /*                    */ 0b0000000000000000000000010;
const Update = /*                       */ 0b0000000000000000000000100;
const PlacementAndUpdate = /*           */ Placement | Update;
const Deletion = /*                     */ 0b0000000000000000000001000;
const ChildDeletion = /*                */ 0b0000000000000000000010000;
const ContentReset = /*                 */ 0b0000000000000000000100000;
const Callback = /*                     */ 0b0000000000000000001000000;
//...只列出部分
```

使用二進制操作，可以利用按位操作，很方便求出操作的 交、并、補集。即能用一個二進制數值來表示一個或多個操作的聚合關係。



為何要使用這個布爾值來使首屏渲染和更新渲染不同呢？

因為在首屏渲染時，currentFiber是空的，和workInProgress比較則每一個節點都是不同的。如果不加處理，則我們的每一個Fiber節點都會被標記為`Placement`（插入），那麼就會把節點進行逐個插入，是十分低效的。



為此，如上例子，在[首屏渲染](###Render 阶段)之時，傳入`beginWork`函數的current Fiber除了第一個HostRoot之外，其它都是`null`，因此，在這之後所有的子 Fiber，都會進入 `mountChildFibers` 這個函數。它的所有子Fiber節點都不會被附上 effectTag。

但在根節點，它的current不為`null`，因此，只有根節點會被標記為`Placement`。整個渲染只會插入根節點一次，相當於`set innerHTML`



#### completeWork 阶段

```typescript
function completeWork(current, workInProgress, renderLanes) {...}
```

工作流程：

1. 和`beginWork` 類似，會根據 Fiber 的`tag`類型，進入不同的邏輯

   ```typescript
   switch (workInProgress.tag) {
       case IndeterminateComponent:
       case LazyComponent:
       case SimpleMemoComponent:
       case FunctionComponent:
       case ForwardRef:
       case Fragment:
       case Mode:
       case Profiler:
       case ContextConsumer:
       case MemoComponent:
         return null;
       case ClassComponent: {
         // ...省略
         return null;
       }
       case HostRoot: {
         // ...省略
         updateHostContainer(workInProgress); 
         return null;
       }
       case HostComponent: {
         // ...省略
         return null;
       }
     // ...省略
   ```

   

2. Host Component的  `completeWork` 流程：

   若為組件的 update，則會進入：

   ```typescript
   if (current !== null && workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);
    	//... 
   }
   ```

   而 `updateHostComponent` 的主要工作：

   1. 產生 **updatePayload**

      ```typescript
      const updatePayload = prepareUpdate(...);     
      // 存放有[updateKey,updateValue, ...]的props更新數組
      // 如 ['title','updatedNewTitle','src','newSRC']  
      ```

   2. 把產生的updatePayload 附值給 `workInProgress.updateQueue`，留待commit 階段處理。

      ```typescript
      workInProgress.updateQueue = updatePayload;
      ```

      

   若為組件的 mount, 則會進入：

   ```typescript
   else {
    const instance = createInstance( // 創建對應的原生 DOM 節點
       type,
       newProps,
       rootContainerInstance,
       currentHostContext,
       workInProgress,
     );
     
     appendAllChildren(instance, workInProgress, false, false); // 把 DOM 結點插入
     
     workInProgress.stateNode = instance;  // Fiber 的 stateNode 對應剛生成的 DOM 結點
   
     if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
        markUpdate(workInProgress);
     }
   }
   ```

   

### Commit 阶段

commit 階段的入口：

```typescript
function commitRoot(root) {
	var previousUpdateLanePriority = getCurrentUpdatePriority();
  
  try {
		//...
    commitRootImpl(root, previousUpdateLanePriority); //實際 commitRoot的入口
  } finally {
		setCurrentUpdatePriority(previousUpdateLanePriority);
  }
  return null;
}
```



commit 階段的工作，根據更新UI的時機，主要分為三個部分：

- Before Mutation 階段 （更新DOM前）
- Mutation 階段 （執行更新DOM的操作）
- Layout 階段 （更新DOM之後的操作）



#### Before Mutation  之前的準備工作

1. 清空所有的 PassiveEffect (由`useEffect` 引起的副作用 )

```typescript
do {
    flushPassiveEffects();
} while (rootWithPendingPassiveEffects !== null); 
// 一直循環至所有passive effect都被調用 因useEffect可能產生新的副作用
```



#### Before Mutation

```typescript
// Before Mutation 階段入口：
// The first phase a "before mutation" phase. We use this phase to read the
// state of the host tree right before we mutate it. This is where
// getSnapshotBeforeUpdate is called.
commitBeforeMutationEffects(root, finishedWork);
```



```typescript
function commitBeforeMutationEffects(
  root: FiberRoot,
  firstChild: Fiber,
) {
  focusedInstanceHandle = prepareForCommit(root.containerInfo);

  nextEffect = firstChild;
  commitBeforeMutationEffects_begin(); // 最主要是調用 instance.getSnapshotBeforeUpdate

  // 處理Blur相關
  const shouldFire = shouldFireAfterActiveInstanceBlur;
  shouldFireAfterActiveInstanceBlur = false;
  focusedInstanceHandle = null;

  return shouldFire;
}
```

`getSnapshotBeforeUpdate` 是 對被標記為 **”unsafe“** 的生命周期函數的代替版本（`componentWillMount`和`componentWillUpdate`），是在beforeCommit階段調用。

因為Fiber架構的render階段可能隨時被高優先級的更新打斷，此時上述的 `componentWillXXX`是在render階段調用，則會存在多次調用的情況。

在Fiber架構中，為配合render階段的高優更新打斷機制，這類更新前的函數從原來的render階段放到了commit階段。commit 階段是同步的，因此不會被打斷，也就不存在反覆被調用的問題。



在此之後，以 **Normal** 優先級調度 passiveEffect ( useEffect 中注冊的回調函數 )

```typescript
if (
    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
    (finishedWork.flags & PassiveMask) !== NoFlags
  ) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      scheduleCallback(NormalSchedulerPriority, () => { // 調度
        flushPassiveEffects();
        return null;
      });
    }
}
```





#### Mutation

#### Layout







## React 比较算法 （Diff）

关于 React 的 Diff 算法，它并不是由 React 率先提出的，它普遍的时间复杂度在`O(n^3)`左右。但 React 将其改良，提出了**两点假设**

```
1. Two elements of different types will produce different trees.
两种不同类型的元素，它们生成的子树不同。

2.The developer can hint at which child elements may be stable across different renders with a key prop.
开发者可以为子元素提供不随渲染而变的key属性，来帮助React寻找变化的组件
```

建立在这两点基础上的 diff 算法，时间复杂度可以达到`O(n)`

比较环节：

React 会从根节点开始**由顶至底**进行比较，使用的方法是同层级比较，

采用深度优先遍历，父组件更新影响到子组件的更新



整个Diff算法的开始是在`reconcileChildFiber`这个函数中进行。

从源码中，React在这个函数中划分了三个大的情况，一是children为string/number/Object的情况，一是children为Array的情况，因此我们也可以分为单结点diff，多结点diff 进行讨论：

**单结点的Diff**，调用`reconcileSingleElement`.总的来说，React会先比较`key`，再比较`type`，只有这两个都相同的情况下，一个节点才有机会被复用。

- key改变，直接断定不能复用

- key相同、type不同，那么之后的比较已经没有意义，在那之后的兄弟结点都会被标记为删除。

- key相同、type相同，那么会对其利用props产生的子节点进行reconcile。



**多结点的Diff**

React团队认为，不同操作是具有优先级的，组件 **更新（替换）** 比 **新增/删除** 的优先级更高，因此React会优先处理 节点的 **更新** 操作。

在React的多节点更新 —— children为数组的更新中，会经历两次的更新：

1. 处理 **更新** 的节点；
2. 处理 **非更新** 的节点



一轮遍历：

1. `key`不同，立刻停止；
2. `key`同，`type`不同，旧的节点标记为Deletion

遍历直到JSX对象的children或old Fiber 树的任一方遍历完成，第一轮的遍历就完成了；

主要目的是为了找到`key`和`type`相同的节点



二轮遍历：

是在一轮遍历的基础之上进行，有以下三种情况：

1. 两方均完成，结束；
2. 一方完成，一方未完成 => 剩下节点全部为Placement或Deletion；

3. 两方都未完成，证明key发生了改变，也就是发生了位置的交换；

在此时，React会构建的结构`Map<Key,Fiber>` ，来快速以key来找到对应的Fiber节点。

在每个Fiber节点上，有一个名为`oldIndex`的属性，代表了它更新前，在children数组之中的索引值。

在遍历过程中，只要循环的index比`oldIndex`大，说明存在了位置交换（在上面的节点跑到了下面），就会给它打上向下移动的标记



**结论：React只会把节点向下移**

因此也有一个性能的考量：尽量是上面节点向下移，而减少下面的节点向上移。

`abcd => dabc` 实际上是把abc移动到d之后，而不是把d移动到abc之前。



## Hooks 理念

两个理解：Hook 的设计模式 以及 Hook 对于React 内部数据结构的实现：

1. Hook 设计模式，即是在函数式组件中对可重用逻辑，其中包括了会产生副作用的逻辑进行封装的思想。这解决了在Class Component之间因想复用逻辑，大量使用High-Order Component而产生的wrapper hell的现象

   我们自己定制的hook, 是对涉及到副作用的hook进行有限的整合和封装，它的功能更纯粹，细粒度更高。

   我们使用的Component在React的世界，就像在宏观世界中的原子，代表了页面UI最小的单元，Component的属性、类型决定了UI的行为和外观。

   而Hook更像是电子，它介入到了物质的运行规律之中，决定了原子相应属性的表现。

   我们之前使用ClassComponent中的生命周期函数, 其实只是在原子层面对组件进行抽象的调用，而hook能深入到整个React的运作之中。能更好地对组件的行为、正在做的事情进行封装和抽象，而不是基于生命周期进行拆分。

   

2. Hook，在React内部是一种数据结构。和UpdateQueue的结构是 十分类似但有不同。

   hook，具有和Fiber updateQueue基本一致的属性如`baseState`,`memorizedState`等，也具有一致的数据结构，也就是**单向循环链表**的结构。

   

   每个hook中有一个`queue`属性，它之中的`pending`存放了`Update`的数据结构。和Hook本身一样，它也是一个单向的循环链表，它代表了调用这个hook中产生的更新。在合适的时机，React会flush这个hook.queue.pending链表，应用所有等待更新的Update。

   

   一个组件之间可能存在着多个hook调用，它们之间利用next指针相连，链表尾指向链表头。整个链表挂在了相应fiber节点的`fiber.memorizedState` 之上。

   

   `fiber.memorizedState`一直指向的是hook的链表尾；

   这样做的好处在于，能用一个指针，就能同时记录整个链表的头和尾，且十分便利地在链表的尾部进行插入。

   

   React Hook中引入了Redux的许多概念，dispatcher / action 等，我们能在hook的相关源码中随处发现。所有的hook实际运行的逻辑，其实都挂在dispatcher对象之上。

   mount和update时，hook的实现逻辑是不一样的，取决于挂载hook的dispatcher是哪一个

   

   所有的hook，都利用`memorizeState`这个属性来存放hook相关的计算值。

   比如：

   - useMemo 存放的是`[value,deps]` 
   - useCallback 存放的是`[callback,deps]`
   - useRef 存放的是 ref

   



## React 模式

- Legacy 模式
- Concurrent 模式



## 数据流

### 单向数据流

单向数据只是一个数据传递的方式，并不是 React 独有的。数据只能有一种方式在应用的两个部分传递。

在 React 中，具体表现为：

组件**执行操作** ==> 发送出事件

事件中的数据 ==> 更新状态

状态中的数据 ==>**更新**视图/UI 组件

这是一个单向而不可逆的流动，这带来的好处有：

1. 能知道从哪里来，到哪里去，便于**排查和控制**
2. React 知道传递的边界，因此可以减少推测，提高速度
3. 更好去配合统一状态管理

### 组件之间的通信方式

- 父 => 子： 利用`props`参数传递; context API
- 子 => 父 ： 利用引发事件，携带相应数值向上传递;context API
- 兄弟之间：兄 A =事件=> 父状态更新 ==> 兄 B props

### 事件绑定原理

React 的事件不会直接加入到原生 DOM 事件中，而是通过 React 的`SyntheticEvent`（合成事件）来进行代理; 此处不会涉及到 DOM 的 API，可以把这也是 React 可以把事件系统应用到不同平台上的关键

在 ReactDOM 中，事件的处理分为两个阶段，分别为**事件注册**和**事件分发**

- 事件的注册

  总体来说，ReactDOM 会把所有的事件注册在`document` / `RootNode`之中，统一通过`dispatchEvent`来分配事件

  在编译 JSX 的时候，React 会把所有相同事件的组件按一定顺序放在数组中，方便查找

- 事件的触发和分发

  1. 利用原生事件找到`event.target`,找到对应的组件
  2. 利用 React 的`findParent`方法把所有的父组件对应事件的回调函数找到，放到一个事件队列之中
  3. 依顺序执行队列中的任务（React 中冒泡的实现，本质上是数组的遍历）



## 其它概念

### 生命周期 （旧）

- 装载(Mounted)
  - function Object() 
  - componentWillMount // React.16 废除
  - mount
  - componentDidMount
- 更新(Updated)
  - componentWillReceiveProps // React.16 废除 能访问到 this.props 会影响更新判断
  - shouldComponentUpdate
  - componentWillUpdate // React.16 废除 此时读到的 DOM 可能会失效
  - update
  - componentDidUpdate
- 卸载(Unmounted)
  - componentWillUnmount
  - unmout
  - componentDidUnmount

之所以废除了上述的生命周期，是因为上述的`componentWillXXX`会在render阶段调用，而render阶段在 Fiber Reconciler的架构之下随时会被打断，重新执行。因此上述的生命周期函数有可能会被调用多次，因此得到的很有可能是过期的数据，因此它们是不安全的。

实际上，生命周期是基于组件层面的，React 引入 Hook概念之后，生命周期的概念被弱化，取而代之的是 `Effect` 也就是副作用的调度。

### 可控组件 不可控组件

- 受控组件：

  在`<input>`等的表单元素，它本身的值绑定在 React 的`state`之上，元素内部不负责管理`value`。它的值只能通过设置事件处理，把输入同步更新到`state`之后才能更新`<input>`的值。它的值完全被`state`所控制，称之为可控组件。

- 不可控组件：

  这种情况下，`<input>`元素的值由 DOM 元素自身管理，不受 React 代码的控制。此时用户输入的任何值都可以显示到页面上；

  常用`useRef`提出的引用值来获得 DOM 元素的值。



### React state 不可变性

不可变性主要针对 JavaScript 的引用类型，在 JavaScript 中，而引用对象的会被放在堆内存之中，以地址的形式引用，可被多个对象同时引用。一旦其中一个修改时所有引用这个地址的对象都会受到影响。

不可变值意味我们每次都要创建值和地址完全不同的对象；

那么在 React 的 Reconcliation 过程中，我们就可以只简单比较内存地址的变化，就能判断组件的值是否需要更新了；如果不这么做，那我们就有可能对传入对象进行深入比较，这样对性能的影响是极大的；

# Vue

## Vue和React的比较

## Vue2.0 和 Vue 3.0







# 网络 浏览器

## URL到渲染页面

1. 浏览器会检查 URL 中的各部分，分析出域名，子路由，URL 参数等；如果用户没有输入完整，则一般会作为搜索引擎的条件处理；对参数进行`encode`

2. 检查浏览器中的 Preloaded - HSTS（**H**TTP **S**trict-**T**ransport-**S**ecurity）， 一种安全保护机制。若要访问的 URL 在这个列表之中，则会强制发起 HTTPS 请求。

3. 检查浏览器的缓存，如果满足强缓存的条件，直接使用原页面

4. 进行**DNS 的查找**

   首先会检查浏览器上的 **DNS 缓存**，有就使用该结果

   其次会调用 OS 上的`gethostbyname`方法，找 OS 上的**host 文件**，如果上面有就用这个结果；（被人改 Host === DNS 劫持）

   下一步，会到本地 LocalDNS 服务器查找，这一般是运营商建立的 DNS 服务器，如果上面有就用它返回的结果

   如果没有，则本地服务器向根服务器查询，它会告诉本地服务器 主域服务器的地址（.com / .org ）等

   LDNS 从这些主域服务器中获得相应的 IP 地址，再一层层返回；得到的 IP 地址会被收入缓存之中，放便下一次的访问

5. 用户得到 IP 地址之后，会**随机**从本机可用的端口中选一个端口, 开始向**服务器的相应端口**请求，如果是 HTTP => 80 / HTTPS => 443

6. 开始建立**TCP**连接

   TCP 连接的过程经历了三次握手，双方在交换 SYN 和 ACK 标志数据包之后，会进入**建立（ESTABLISHED）状态**，双方进入了可靠的连接状态

7. 如若要求使用 HTTPS 连接，双方则会开始进行**TLS Handshake**。

   - 用户向服务端发送`ClientHello`,包含了 **可用 TLS 版本**，**可用加密，压缩算法**，
   - 服务器回送`ServerHello`，包含服务器所选的 **TLS 版本，算法**，并附上自己的 **数字证书**，内含了它的 **Public Key**；
   - 用户收到之后验证证书可靠性，之后生成**对称密钥**，用服务器的**Public Key**加密，这时候，只有服务器持有的 **Private Key**能解密。
   - 服务器得到加密包后，用自己的 **PrivateKey **解密。此时，双方都得到了相同的对称密钥
   - 用户会向服务器发送一次验证，保证服务器收到的是有效的密钥，服务器回应之后可以正式开始使用加密的 HTTP 通信

8. 开始进行**HTTP 请求**

   用户端向服务器发送 HTTP GET 请求。 因 HTTP 是无状态连接，必须附带上一系列的请求头，指明请求的信息。

   值得注意的是和缓存有关的请求，`If-Modified-Since`和`If-None-Match`。服务器比较``If-None-Match`传来的**Etag**值和 `If-Modified-Since`时间，如果满足缓存条件，则返回 304 状态码，告知用户使用本地缓存；否则服务器把 HTML 文件发送给用户，返回 200 状态码

9. 用户得到 HTML 文件之后，会由上至下进行 HTML 语法的解析（Tokenize），然后开始构建各个 DOM 结点，最终生成一个 DOM 树

10. 在此期间如有外部引入的文件，则会并行下载，CSS 文件会生成 CSSOM 树，表示样式选择器的结构。

11. DOM 和 CSSOM 会合成 Render Tree，表示实际会渲染到画面上的结点，

12. 计算各节点的布局 ， 再把布局之后的结点绘制到页面上

13. 作为较好的习惯，一般把 JS 文件置于最后下载和运行

## DNS

**流程：**

1. 本地host
2. 本地域名缓存
3. 本地域名服务器
4. ==> 根域名服务器 ==> 顶级域名服务器 （不返回） ==> 二级域名 ==> 三级域名 ==> ......

#### 负载均衡

当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在**「DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器」**,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。

#### 为什么域名解析用UDP协议？

因为UDP快。UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。

#### 为什么区域传送用TCP协议？

因为TCP协议可靠性好。从主DNS上复制内容，不可用不可靠的UDP，而且因为TCP协议传输的内容大，不可用最大只能传512字节的UDP协议，因为同步的数据可能大于512字节。



## OSI 模型

1. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为 1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。

2. 数据链路层：定义了格式化数据以帧为单位进行数据的传输，对帧的编码，以及如何让控制对**物理介质的访问**，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。

3. 网络层：在位于不同**地理位置的网络中的两个主机**系统之间**提供连接**和路径选择，Internet 的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。

4. 传输层：定义了一些**传输数据的协议和端口号**（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。

5. 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的**系统之间发起会话或者接受会话请求**（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）。

6. 表示层：**数据的转译。**可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC 程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现**多种数据格式之间的转换**。

   SSL/TLS对明文的加密也发生在此

7. 应用层： 是最靠近用户的 OSI 层，这一层为**用户的应用程序提供网络服务**。 （HTTP FTP）

## TCP / UPD

#### 三次握手

第一次握手 客户端生成其初始序列号 X，向服务器发送连接请求报文（SYN），不带数据，但会占用一个序号位置

第二次握手 服务端收到请求后，也为自己生成一个序列号 Y；如果同意连接，则会发出确认报文（SYN / ACK），也会占用一个序列位置；

第三次握手 客户端收到请求要再次发送确认，

此时双方都保证接收能力无误，可以开始通信了

为什么不用两次？

如果第一次握手时发生了滞留，客户端没有收到 SYN/ACK 会再次发送 SYN 到服务端，此时网络中存在了两个 SYN 包。如果没有第三次握手的保证，这两个 SYN 包都会建立一次连接，其中有一次是无效的。

如果有第三次的保证，用户收到无效 SYN/ACK 不回传，就不会建立多余连接。

#### 四次挥手

第一次挥手：用户向服务器主动发出释放报文（FIN）序列号为最后包号+1,表明客户端不再有数据发送了

第二次挥手：服务器应答用户发来的（ACK），但此时可能还有数据没有发送完，服务端还会继续发送，用户还会继续接收

第三次挥手：服务端把所有的数据发送之后，向用户端发送释放报文（FIN），表明服务端已发送完毕，对方可以关闭接收功能了

第四次挥手：接收到所有的数据之后，客户端回应服务端，然后会经过 2 倍 MSL（最长报文段寿命）的时间后，再把 TCP 连接关闭

等待 2\*MSL 的时间：

1. 消除网络中因重传而发出的无效的请求报文
2. 保证最后用户发送的 ACK 报文能送到服务端。若中途丢包了，则会服务器会超时重传 FIN 包，然后再重新发送 ACK，因此要等待一定时间。

四次挥手的必要性：

为保证客户端接收到所有的数据再关闭接收功能

#### TCP 数据的正确性？

- **确认应答机制**： 每一个 TCP 数据包都有对应的 ACK 序列号，一方发包之后，另一方会回应一个序列号，来表明当前发到哪里了，下一个包在哪里开始发送。

  如果有发者和收者的序列号不同，则可以计算出丢失的包重新发送。

- **超时重传机制**：有可能因为拥堵，有些包没能到达接收方。因此 TCP 设计了一个 **最大超时时间**，超过了就会重新发送这些丢失的包。最大时间是动态调整的，间隔会以指数型式增长，保证网络性能，直到超过一定次数，判断出现异常。

- **滑动窗口**： 简单说就是一次性发送一定数量的包，无须逐个等待 ACK。它就像个窗口一样不断向后滑动，所以称作滑动窗口

- **快重传**：以滑动窗口集中发送如果丢包，接收方会不断返回丢包序列号的 ACK，来告诉对方要重发，至少三次之后发送方会重新把丢包的重发

- **流量控制**：接收端可以通过 TCP 中的窗口大小字段，来调整发包速率。防止因大量数据发向接收端，接收端缓存满而引致的大量丢包

- **拥堵控制**：也是俗称的 **慢启动**，目的是试探接收方允许的最大的接收速率，之后会逐步加大传输速率。主要目的是为了防止丢包

#### TCP 和 UDP 的区别

- **UDP（User Datagram Protocal）用户数据报协议**

  - 无连接：过程双方不需要建立连接，只要知道对方 IP，端口就可以发送
  - 面向数据报：应用层传来什么数据，原样发报，不拆分不合并
  - 不可靠：UDP 不存在 TCP 中的 **重传机制**，**确认机制**，其只保证了发送出去，不保证它能到达接收者
  - 没有拥堵控制，流量控制，滑动窗口等发包控制机制
  - 速度快，花销少：因不用经历三次握手的来回时间，且报文首部短小，发送速率不调整而速度快

  常用在 DNS NFS

- **TCP （Transmission Control Protocal）传输控制协议**

  - 有连接
  - 面向字节流：如果要发送的字节流过长，会发送成多个数据包发出；太短会在发送缓冲区，到达一定长度再发送
  - 可靠性：丢包重传，收包确认等机制保证了所有包都能到达接收方，且保证了接收方能按顺序得到包的原数据，有流量控制，拥堵控制等机制来降低丢包率。
  - 速度不快，因要进行三次握手以建立稳定的连接，四次挥手保证所有包的送出





## HTTP 和 HTTPS

### HTTP 和 HTTPS 的区别？

HTTPS 为加密版本的 HTTP，利用 SSL/TLS 对传输内容加密，更加安全。



### HTTP 状态码

| 100     | Continue                 | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
| ------- | ------------------------ | ------------------------------------------------------------ |
| **101** | **Switching Protocols**  | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 |
|         |                          |                                                              |
| **200** | **OK**                   | 请求成功。一般用于 GET 与 POST 请求                          |
| **201** | Created                  | 已创建。成功请求并创建了新的资源                             |
| 202     | Accepted                 | 已接受。已经接受请求，但未处理完成                           |
|         |                          |                                                              |
| 301     | Moved Permanently        | 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替 |
| 302     | Found                    | 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI |
| 303     | See Other                | 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看         |
| **304** | Not Modified             | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
|         |                          |                                                              |
| **400** | Bad Request              | 客户端请求的语法错误，服务器无法理解                         |
| **401** | Unauthorized             | 请求要求用户的身份认证                                       |
| 403     | Forbidden                | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| **404** | Not Found                | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面 |
| **413** | Request Entity Too Large | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息 |
|         |                          |                                                              |
| **500** | Internal Server Error    | 服务器内部错误，无法完成请求                                 |
| **502** | Bad Gateway              | 由于服务器当前链接太多，导致服务器方面无法给于正常的响应,产生此类报错 |

### HTTP 请求头

`Accept` ： 接收格式

`Accept-Encoding`    ：接收语言

`Host`  ： HTTP访问的域名



`Cache-Control` ： 本地缓存时效性

`Connection` ：连接方式 `keep-alive` 



`If-Modified-Since`

`If-None-Match`

`User-Agent`

`Cookie`



### HTTP 响应头

Conntent Type

Content-Length

Etag

Last-Modified

Content-Encoding

Set-cookie





### HTTP 方法

GET

HEAD => Response 只提供 Header

POST => 不一定存在

PUT => 己存在资源

DELETE

OPTIONS => Response 返回支持的方法

- GET vs POST

  - POST 比 GET 慢

    - **POST 请求包含更多的请求头**

    - **POST 会先将请求头发送给服务器进行确认，然后才真正发送数据**

      100 Continue => 200 OK

    - GET 有**最大长度限制** 浏览器和 web 服务器限制了 URL 的长度

  - POST 更**安全**（不会作为 url 的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）

  - POST 能发送更多的数据类型 vs GET 只能发送 ASCII 字符



## SSL / TLS 

#### SSL 和 TLS 的区别

如若要求使用 HTTPS 连接，双方则会开始进行 **TLS Handshake**。

- 用户向服务端发送`ClientHello`,包含了 **可用 TLS 版本**，**可用加密，压缩算法**，

- 服务器回送`ServerHello`，包含服务器所选的 **TLS 版本，算法**，并附上自己的 **数字证书**，内含了它的 **Public Key**；

- 用户收到之后验证证书可靠性，之后生成**对称密钥**，用服务器的**Public Key**加密，这时候，只有服务器持有的 **Private Key**能解密。

- 服务器得到加密包后，用自己的 **PrivateKey **解密。此时，双方都得到了相同的对称密钥

- 用户会向服务器发送一次验证，保证服务器收到的是有效的密钥，服务器回应之后可以正式开始使用加密的 HTTP 通信

  

#### 对称加密和非对称加密 , 为何要混合使用？

对称加密指加密 解密都用同一把钥匙，

而非对称加密会生成公钥和私钥，公钥加密的内容只有私钥能解开

单一对称加密的问题是在密钥的分发上，钥匙的分配要经过网络，那么就有被拦截的可能；

而单一的非对称加密，其发送过程中公钥很容易被中间人偷换，这就是所说的中间人攻击；

因些，可以两种结合，把对称密钥用非对称公钥加密，再另一方再用私钥解密，就能安全进行密钥的交换了



#### 数字证书

本质上是一个信任链条，它由 CA 签发，它能证明某个网站可信，或是某些内容是可信的

## CDN

Content Delivery Network 内容分发网络

它把一个服务器网站的内容发布到各地的服务器上缓存，在用户请求时可以使用户就近得到缓存服务器的内容，能减少用户因内容服务器过远而造成的网络延时。

原理：

用户请求静态资源时，会进行 DNS 解析，但此时 DNS 会优先解析出来指向离用户最近的 CDN 的接入地址 （CName）， 用户就可以向这个最近的地址请求获取资源了。



## 同源与跨域

### 同源策略

同源策略是浏览器的一个核心的安全功能，它可以限制一个源的内容或脚本在另一个源的应用上运行；它能阻挡很多恶意的文档，减少被攻击的可能。

在同源策略下，请求是可以正常发送的，但不同源的文件是不会被浏览器所接受的。

同源，就意味着 **域名**+**协议**+端口都必须一致，才能被浏览器所接受

同源限制了 Ajax 请求， Cookie LocalStorage SessionStorage 和 DOM 交互

### 跨域的方式 解决方法

- JSONP： 使用 JSONP 进行跨域，本质上是利用了`<script>`标签中的`src`可以无视同源策略的属性

  但要求服务端返回的是可执行的 JS 语句，才能在页面中执行

  ```javascript
  //Backend...
  route.use(async (req,res) => {
    const {callback} = req.params;
  	const data = await getData()
  	res.send(`${callback}(${data})`);  
  })
  
  
  
  //Frontend...
  const handleData = (data) => {
    console.log('Do something with:', data);
  };
  
  const scriptEl = document.createElement('script');
  scriptEl.src = 'http://api.backend.com?callback=handleData';
  
  document.body.appendChild(scriptEl);
  ```

  仅适用 GET 请求

- CORS 跨域资源共享：一个 W3C 标准，在服务端回送的请求头中设置`Access-Control-Allow-Origin`和`Access-Control-Allow-Methods（Headers）`，它能和浏览器进行协商，请求该资源放行

  分为简单请求和非简单请求

  - 简单：

    - 使用`HEAD` `GET` `POST` 的请求，浏览器会加一个`Origin`字段就发送出去了

  - 非简单请求
    - 分为两次 HTTP 请求，先用`OPTION`方法预检，主要是求得服务器确认可用的方法等

- 同源策略只用于浏览器，那么可以通过一个和浏览器同源的代理服器来请求，就可以避开浏览器的同源限制了 （Nginx反向代理）

- postMessage 跨域

- 使用 WebSocket 也可以跨过同源限制 （Socket.io）



## 前端安全

#### 常见的攻击方式 预防方案

- XSS（Cross-Site Script）跨站脚本攻击

  通常是利用网站设计的漏洞，发生在可供用户输入的表单元表，或是 url 请求参数上；

  分为两种形式：**持久型**和 **非持久型**

  - 持久型：

    - 攻击者把恶意的代码利用`<script>`标签作为字段放入了服务器之中
    - 用户打开网站，`<script>`会拼接在 HTML 文档中一起返回，到达用户端开始执行，用户的 cookie，localStorage 等可能因些被访问

  - 非持久型：

    - 攻击者把恶意代码拼在 URL 中作为参数
    - 服务器响应，把参数作为 HTML 文件中的一部分返回了，恶意脚本便执行了

  - DOM 型：

    利用 URL 传参功能，原理类似 2

  - 方法：

    - 对 HTML 编码

    - 避免直接拼接 HTML

    - 使用 Content-Security-Policy 这样的一个请求头，建立可信任内容的白名单

- CSRF （跨站请求伪造）

  - 引诱他人在已经登陆 a.com 的情况下访问 b.com
  - 此时 a.com 的登陆凭证可被 b.com 使用，若 b.com 向 a.com 发送请求，那么请求中就会带上了 a 的登陆凭证，以 a 的身份完成操作了
  - 一般方式是使用引诱他人点击页面元素/链接 或 `<script>、<link>、<img>、<iframe> `

  - 解决方法：使用 Samesite 的 Cookie 属性
    - `Strict`，只能作为第一方 Cookie 只能由 a.com 使用
    - `Lax`：可作第三方 Cookie 但只能使用 GET 请求-
      -

- 点击劫持

  使用透明的`<iframe>`覆盖在元素的上方，用户点击那些元素的时候实际上点的是`<iframe>`

  使用**X-Frame-Options** Response Header，来限制网页能不能放在`<iframe>`之中

- SQL 注入，把 SQL 语句在表单元素中直接写入





## 前端缓存

### HTTP 缓存策略

#### 强缓存

通过特殊的 HTTP Cache-Control 首部 或 Expires 首部，HTTP 让原始服务器向 每个文档附加了一个“过期日期”。

`Expires` 使用绝对时间，依赖于计算机时钟的正确设置。 

`Cache-Control: max-age` 使用相对时间 （优先级高）

#### 协商缓存

已缓存文档过期不等于真正失效，因此需要询问原始服务器缓存的文档是否发生了变化。

1. (request) **If-Modified-Since** : Date <=>  (response) **Last-Modified**

- 如果自指定日期后，文档被修改了，If-Modified-Since 条件就为真，通常 GET 就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。

- 如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回一个小的**304 Not Modified** 响应报文，为了提高有效性，不会返回文档的主体。16 这 些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如， Content-Type 首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。

- If-Modified-Since 首部可以与 Last-Modified 服务器响应首部配合工作。原始 服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行 再验证时，就会包含一个 If-Modified-Since 首部，其中携带有最后修改已缓存副本的日期:

  **如果未发生变化，If-Modified-Since 再验证会返回 304 响应，**如果发生了变化， 就返回带有新主体的 200 响应。

2. **If-None-Match：etag**

- 有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。
- 有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。
- 有些服务器无法准确地判定其页面的最后修改日期。
- 有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。 

服务器会返回一个Etag，并在你第二次发起同一个请求时，客户端会同时发送一个If-None-Match，而它的值就是Etag的值（此处由发起请求的客户端来设置。缓存中有一个实体标签为Etag: v2.6 的文档。它会与原始服务器进行再验证，如果标签Etag: v2.6 不再匹配，就会请求一个新对象。假设标签仍然与之 匹配，因此会返回一条 ***304 Not Modified\*** 响应。 如果服务器上的实体标签已经发生了变化(可能变成了 Etag: v3.0)，服务器会在一个 ***200OK\*** 响应中返回新的内容以及相应的新 Etag。



### 持久化存储

#### LocalStorage & SessionStorage

- localStorage 是一个本地化的存储，它没有过期的时间，理论上不删除会一直存在。

- SessionStorage 会在页面关闭之后清除

- **不同页面，但同源**可访问相同的 localStorage；不同页面之间不能访问彼些的 SessionStorage

- 大小 5M

- 不会和服务端通信

- L => 记录长期的登陆； S => 单次的登陆

- 均用 String 存储

  

#### Cookie

- 会作为请求头的一部分随 HTTP 请求一并发送
- 在 Cookie 设置的过期时间前一直有效。即使页面已经关闭，（默认是 Browser 关闭）若设置了过期时间，浏览器就会把 cookie 保存到硬盘上，关闭后再打开浏览器这些 cookie 仍然有效直到超过设定的过期时间。
- Cookie 在同源窗口下共享
- 每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB



## 认证和鉴权

由于 HTTP 是无状态的连接，每次的对话相当于是新的；但我们需要记住用户，来避免用户重复登陆；

- 方案 1: 为每一个用户提供对话标识(SessionId)，并存放在服务器之中，并让用户每次请求都把 SessionId 带来；

  缺点：1）会增加**数据存放量**； 2）**分布式的转发机制**，没办法把 SessionId 同步到所有的服务器上

- 方案 2： JSON_WEB_TOKEN。

  - 服务端把用户非私密信息用私钥+算法算法生成数字签名，
  - 把签名附在信息上返回给用户
  - 用户每次登陆时把相同信息传来，利用服务器中私钥+算法再生成签名
  - 比较签名

  这样在服务器上无需大量存放用户的信息，而是每次进行加密的算法，相当于是一种无状态的请求



### Ajax

Ajax (Async JavaScript and XML) 利用它能做到用户端请求少量数据，局部刷新页面

主要用到的是`XMLHttpRequest`，这一个异步的对象，它封装了向服务端异步请求的功能，把 HTTP 请求接口用 JS 封装；

- Ajax 编程步骤
  - 创建 XMLHttpRequest 对象
  - 设置请求方式
  - 调用回调函数
  - 发送请求

```javascript
//创建异步对象
var xhr = new XMLHttpRequest();
//设置请求基本信息，并加上请求头
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.open('post', 'test.php');
//发送请求
xhr.send('name=Lan&age=18');
xhr.onreadystatechange = function () {
  // 这步为判断服务器是否正确响应
  if (xhr.readyState == 4 && xhr.status == 200) {
    console.log(xhr.responseText);
  }
};
```

Fetch 是对 Ajax 的一个改进，它挂在了 BOM 之上，能全局访问，且基于 Promise

Axios 是对 Ajax 的进一步封装，也利用了 ES6 Promise，能更好地面向前端 MVVM 的方向





## 浏览器内核，组成部分

- 引擎：

  渲染引擎 :  主要是对解释HTML和CSS语法，对网页的内容进行排布，计算网页的显示方式，简单来说是显示页面的内容

   JavaScript引擎：解释和执行JavaScript语言，利用JavaScript来和页面进行动态的交互

- 其它部分：

  - 用户的界面（地址栏，按钮，书签等）

  - 网络层（实现HTTP/ FTP）等的文件传输

  - 数据持久层：

    它可以将和浏览器相关，需要持久化的数

- 有哪些？

  - 渲染引擎
    - Chrome / Chromium 系：Webkit => Blink内核
    - Firefox：Gecko
    - Safari: Webkit 
    - 也有使用双内核的
  - JavaScript引擎
    - Chromium 系：V8 => Node.js / Electron.js
    - SpiderMonkey : Firefox









# 工程化



## Webpack

### Webpack 核心

- `Compiler`

  它是 webpack 负责全局的设置管理，调度编译过程的对象，所有的配置，比如说 **Plugins**，**Loaders**，设置项等都在这个全局的实例之中

  可以被理解为一个 Webpack 的实例

- `Compliation`

  指的是单次编译的流程，每当文件有所变化，一个新的 Compliation 实例就会被创建

- Life-Cycle & Event-flow

- 核心思想，每个文件都是 Module

### Webpack 的打包流程

1. 参数初始化：读取 CLI 参数，Webpack配置文件，合并成最后参数。

2. 利用上述参数，创建 `Compiler` 对象。整合与加载插件，RuleSet等。

3. 执行`compiler`对象的`run` 方法，创建新的 `compilation` —— 构建过程

4. 从配置项中的 `Entry` 出发，对每个文件执行：

   - Loader 进行文件的转译
   - JS文件调用 JS 解释器，得到AST，从中解析依赖关系。
   - 把得到的依赖关系加入到 depenency graph 之中
   - 重复本步骤，直到没有依赖为止

5. 编译之后，进入 seal 阶段，所有的文件会形成模组，之后按一定规则形成 chunk.

   Chunk形成的基本规则：

   - Entry所能达到的模块，组合成一个大chunk

   - 使用动态引入的模块，自己成为一个chunk

     

   此外，可以使用优化插件 `CommonChunkPlugin` `SplitChunksPlugin` ，去除模组重复打包的问题。

6. 文件会利用 fs 输出到 output目录，如果打开了观察模式，每一次变化就会重启 Compliation 过程；
7. 如果有设置`dev-server`,则会把静态资源发送到浏览器上，并观察更新

### Dev-server

本质上是一个 Node + Express 的服务器，和浏览器之间使用 Websocket 进行双向的通信

### Webpack 中的 loader 和 plugin 的区别

Loader 本质上是一翻译作用的中间件，它能处理文件中的内容，根据预设和规则，把一种文件内容输出成另一种形式，

Plugin 更加的万能，它深入了 Webpack 的构建过程和生命周期。Webpack 在运行之间提供了很多可供调用的 Hooks，它可以访问此刻的编译状态，对它做出一些改变等等

### 如何自己写 Plugin

实现 Webpack 的 Tapable 接口中的`apply`方法，它会传入 complier 实例，可以作出自己的实现。

```js
class SomePlugin {
    apply(compiler) {
        compiler.hooks.thisCompilation.tap('SomePlugin', (compilation) => {
            compilation.hooks.optimizeChunkAssets.tapAsync('SomePlugin', ()=>{});
        })
    }
}
```



它内部的机制是采用了发布订阅的思想，Plugin 会注册到 complier 相应周期的处理函数队列之中，到了那个时候会按队列依次去调用

### 如何自己写 Loader

本质上是类似流式 中间件的思想

### 常用 Loader 和 Plugin

- Loader：

  - CSS-Loader ： 处理`@import`，模块化的 CSS
  - Style-Loader ： 生成 HTML 中的行内 CSS
  - File-loader
  - Image-loader: 可以对图片进行一些压缩处理
  - Bable-Loader：最重要的 Loader，可以对 JavaScript 代码进行各种形式的转译
    - Transform-runtime：Polyfill
    - Env: ES 所有新特性
    - `preset/react`
    - `preset/typescript`

- Plugin:
  - HtmlWebpackPlugin : 自动生成或修改 HTML，比如动态注入`<script>`标签等
  - ModuleFederationPlugin
  - CommonChunkPlugin
  - DefindPlugin，可自已定义变量供应用使用，一般是一些环境变量
- 工具：
  - Webpack-merge 根据所在的环境，应用不同的设置文件，并能对公共部分进行整合

#### Source-Map

源代码到构建后代码映射



#### HMR

替换、添加或删除 模块，而无需重新加载整个页面。

1. 本地 compliation 流程完成，生成新的文件和Hash，发送到client，client把 hash 暂存，等到所有的hash 完成，发送type === OK
2. 浏览器根据刷新策略进行 `reload` ，判断的根据是 客户端的 HMR runtime，调用其中的 `check ` 方法判断使用全页刷新，还是模块热更新
3. 获取更新时，客户端会发送 `Ajax`请求，请求客户端有无更新文件；利用JSONP方式请求最新模块的代码，返回给HMR runtime
4. 调用 HMR runtime 中的 `hotApply ` 方法，移除过期模块，添加新模块 （调用`__webpack_require__`）执行最新的代码





#### **Webpack 文件 Hash**

- `Hash` —— 整个项目的 hash，有一处改变，则都会作出改变。
- `ChunkHash` —— Webpack 代码块Chunk 的 hash
- `ContentHash `  —— 只针对文件内容改变而变的 hash 如JS中引用CSS, 改变JS文件而不希望CSS文件的Hash改变



#### Tree shaking

无效引入依赖的去除；

原理，三阶段：

1. Make阶段：生成 dependency graph
2. Seal 阶段：遍历 dependency graph，标记没有被使用的导出变量
3. 生成chunk时，根据 seal 阶段的标记，移除对应的引入导出语句



根据`import`/`export`的关系来静态分析

```javascript
// Import everything (NOT TREE-SHAKABLE)
import _ from 'lodash';

// Import named export (CAN BE TREE SHAKEN)
import { debounce } from 'lodash';

// Import the item directly (CAN BE TREE SHAKEN)
import debounce from 'lodash/lib/debounce';
```

### Webpack 5

- 输出结果可设置：

  webpack 4 默认只能输出 ES5 代码

  webpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码.

  如：`output.ecmaVersion: 2015`




## Rollup

## Vite

### 本质

- 开发环境下： 基于 `ESBuild` 的开发服务器
- 生产环境下：基于 `rollup` 的打包工具



### 诞生环境

1. 我们在使用 Webpack 进行应用开发环境的构建的时候，都需要预先把所有的模组进行打包。在开发环境下的构建是无视 code splitting 的设置，因此当我们的应用上了规模，构建速度、刷新会非常慢。

2. 我们目前主流的浏览器都支持了原生的 ESM 模组语法 `import/export`，且我们开发者在编写应用的时候都使用 ES Module进行开发。



### 特点

1. 使用原生 ES Module

   在 Vite 生成的项目中，我们会在 `index.html `中引入 `type="module"`的 `<script>`，浏览器会检查之中的 `import/export`函数，去作出对应的HTTP请求，解析得到的文件，找到下一个文件，一直不断地去执行。

   和传统基于 Node.JS 的打包工具如webpack，因为这层逻辑交由了浏览器底层的C++代码去执行，因此会比webpack 更快。

2. 动态引入的文件只有在真正被需要时才会被获取，它不需经过事先的完整应用的打包流程，因此它可以瞬间起动

3. ESBuild 是基于 Go 开发的服务器，相比Webpack =>  express 服务器而言速度会更快



### 问题、解决

1. 文件过多，引起HTTP 请求数量过多

   解决方法：

   	1. 对第三方依赖进行预打包，一个依赖打包成一个包，对应一个HTTP请求
    	2. 利用浏览器的 HTTP 缓存 ——利用ETag + 304协商缓存
    	3. 代码分块

2. 不支持 bare import  

   ```js
   import { useState } from "react"
   
   import 'style.css';
   import packageJSON from './package.json'
   ```

   解决方法：

   1. 使用轻量的语义分析工具 `es-module-lexer` `magic-string`

      `es-module-lexer` 是 Vite 底层用于分析输入输出关系的工具，因为它不需要对整个代码文件进行 AST的转化，因此它的速度非常快

      `magic-string`  Vite 用于转化输入输出语句，并生成 Dependency Graph 

3. HMR的实现 —— 和 Webpack 十分相似：

   1. 利用语义分析时生成的 Dependency Graph
   2. 声明HMR的边界，也就在模组中引入 `import.meta.hot.accept` 函数
   3. 变化发生时，会根据依赖图，一直向parent模组找，直到找到模组的边界。找到边界，利用WebSocket向浏览器主动推送消息，调用注册在 `hot.accept` 的回调函数。之后浏览器会再发送HTTP请求到服务端，请求新的文件。

   因为Vite在开发环境，代码发生改变之后，不需要对整个应用进行重新打包

   

# 性能优化

## 重绘与回流

- 涉及到布局的重排，位置，大小的重新计算，添加删除，就会引起回流 （Reflow）
- 若元素的属性更新，只影响外观，不会引发布局的改变，则为重绘 （Repaint）

- 它们都是高昂的，

  - 重绘会让浏览器验正其它节点的可见性
  - 回流会引起所有和它相关的元素发生改变

- 减少重绘和回流的方法
  - 不用`table`
  - 常要改的 className 放在末端，因 css 选择器的解析顺序是由右到左的
  - 少用`cacl()`
  - 把动画放在一个单独的图层之上,`fixed` `absolute`,不会影响到别的元素
  - 使用`transform`来移动元素，不会引发布局的改变

## React 优化性能

- 减少 React 组件的重新渲染：

  - 列表中使用`key`

  - 如果不是列表，可使用渲染`null`来维持组件的相对位置

  - 使用记忆钩子函数 `useMemo`和`useCallback`,把一些繁重的计算结果放在之中，给定依赖项，防止每次刷新时重新计算

  - 在组件刷新之前引入判断机制 （组件记忆）：

    类组件中使用`React.pureComponent`

    函数式组件被使用`React.memo`

    它们的原理类似，能对传入的 prop 进行浅比较，如果比较结果不相同，则会重新渲染；

    `React.memo`可在第二个参数中给定比较函数，允许开发者提供比较的逻辑，和`shouldComponentUpdate`很相似

- 使用懒加载组件，这个一般和 Webpack 配合使用

  - Webpack 可支持代码的拆分，把动态加载的组件分别打包成分开的代码块（chunk）
  - 配合使用 React16 之后提供的 `<Suspense>` 组件和`lazy()`方法，加上 ESModule 提供的`import()`方法来动态引入组件
  - 减少一次性加载量，提高首屏渲染

- 使用`<React.Fragment>`来减少没有意义的`<div>`标签等

- 减少文件，资源的体积，采用 gzip 来压缩资源，减少在网络传输的内容

- 减少请求的数量，利用类似雪璧图等的方式把资源拼装再发送

##  Webpack 优化性能

- 减
  - 减小 Loader 的检测和适用范围 `include` `exclude`
  - 减小生成代码的体积，在生产环境中可使用`uglify`插件，把变量名，空格换行等去除
  - 去除无用的代码，可以使用 `TreeShaking`插件，把一些引入而无用的库文件精简
- 动态
  - 在使用频率低的组件，或由路由跳转的组件，可以`import()`动态引入，它们会分别成块，可以实现按需获取
- 公共
  - 可以利用 Webpack 提出公共代码，库，组件， 利用`CommonChunkPlugin` 生成公共代码块，这样可以充分利用浏览器的缓存机制

## 首屏加载时间和优化

- 浏览器渲染包含 HTML 解析、DOM 树构建、CSSOM 构建、JavaScript 解析、布局、绘制等等，大致如下图所示：

  白屏原因：

  - 等待 HTML 文档返回，此时处于白屏状态。

  - 对 HTML 文档解析完成后进行首屏渲染，因为项目中对   

    

    加了灰色的背景色，因此呈现出灰屏。

  - 进行文件加载、JS 解析等过程，导致界面长时间出于灰屏中。

  - 当 Vue 实例触发了 mounted 后，界面显示出大体框架。

  - 调用 API 获取到时机业务数据后才能展示出最终的页面内容。

- CDN
- 骨架，减少白屏时间
- 打包优化



# 计算机原理

## 编译原理

词法分析：字符 => （语义） => TOKEN + 关键字拼写错误 去注释

语法分析：AST生成 把表达式分成 （子表达式）和运算符节点，以树状的形式来表示

语义分析：

中间代码生成

代码优化

目标代码生成



## 进程、线程、协程

### 区别

- 进程是独立运行的一个应用程序，是操作系统资源分配的基本单位（工厂），

  线程是进程之中调度，执行任务的基本单元（工厂中的流水线）

  所以一个进程之中可以利用多个线程进行协作

  

- 在内存分配上，操作系统会给进程分配独立的内存空间，给进程内部分配；

  而线程可以看做轻量级的进程，多个线程共享进程资源，因些可以相互访问和协作

  

- 在执行上，因进程之间相互独立，所以不会相互影响，而线程的崩溃会引起整个进程的崩溃，它依赖于进程为其做调度

  

- 保护机制上，进程崩溃后，很难会对其他进程产生影响，因为它们是独立运行的

  而一个线程崩溃，整个进程就没有办法继续上去了，因为它没法完整去实现它的一功能了。

  

- 通信方式上，线程之间的通信更方便，因为同一进程下的线程可以共享全局变量、静态变量等数据，而进程之间主要通过 通信方式来进行

  进程通信的主要的方法：

  - 管道： 利用一个类似文件的机制，提供读和写的接口，一端读，一端写，就像一个管道一样的机制
  - 共享存储：

  

进程可以说是一个“执行中的程序”。我们可以在一个进程中创建多个线程，让它们在“同一时刻”分别去做不同的工作了。这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步。



### 进程，线程之间的通信

- 进程 - 进程
  - 管道 - 数据单向流动
  - IPC
  - HTTP / Socket
- 线程之间

## 内存

### 堆和栈内存的区别

堆：

- 是一种松散的数据结构，它的内存不连续，大小不定，可动态分配
- 一般会以地址形式引用堆内存中的数据，地址一般存放在栈中
- 内存回收时需要手动回收，程序结束后再自动回收

栈：

- 连续的数据结构，一般由系统动态分配内存空间
- 先进后出，连续存储，高效率
- 回收由系统自动处理





# 音视频直播相关





# 前沿技术

## WebAssembly

## WebGL 

从本质上来讲，WebGL是只是一个 **光栅化 (Rasterization)** 渲染引擎。

光栅，其实是一种视觉欺骗的技术设计。用户从屏幕的一侧看过去，看到的2D图像却能表现出3D的效果。

WebGL利用GPU进行3D图像的计算和渲染，而在浏览器运行的JavaScript在一万米的高空，没法直接利用GPU。因此需要利用较为底层的语言和GPU打交道。因此，一种为GPU渲染设计，专门运行，类C/C++的语言 ——GLSL（GL着色语言）被设计出来。



GLSL提供两种方法——顶点着色器、片元着色器，它们往往成对存在，组合起来成为一个着色程序。

顶点着色器，用于计算图形进行3D变换后，再映射到2D平面每一个点位的坐标位置（裁剪空间坐标）；

片元着色器，在顶点计算完各点位之后，连点成线，连线成面，为每个片元中的像素计算颜色值；



WebGL 的核心就是围绕着：元素在哪？什么颜色？这两个问题进行设计。WebGL只关心两件事：裁剪空间中的坐标值和颜色值。使用WebGL只需要给它提供这两个东西。 你需要提供两个着色器来做这两件事，一个顶点着色器提供裁剪空间坐标值，一个片断着色器提供颜色值。更具体地说，就是如何调用这两种着色器方法，如何维护它们状态值的问题。



基本上所有的几何体，包括一些看似和三角形完全无关的图形，在绘制之时均可用三角形来表示，因此作为了三角形作为WebGL中的Segment，最小部分，不可再分。

在绘制之时，通过调整三角形分片的数目，能控制几何体的渲染质量，边缘的平滑度等。几何体复杂，几何体精度越高，它的分片数量就越多，同时渲染消耗也越大。因此，我们也可以据此作出性能和渲染质量的trade-off.



### WebGL 工作原理

1. 定义容器

利用HTML Canvas元素，生成WebGL上下文

```js
//得到HTML Canvas元素
const canvasEl = document.querySelector('canvas'); // => <canvas>

//生成WebGL上下文
const gl = canvasEl.getContext('webgl'); 
```



2. 准备数据阶段
   在这个阶段，我们需要提供顶点坐标、索引（三角形绘制顺序）、uv（决定贴图坐标）、法线（决定光照效果），以及各种矩阵（比如投影矩阵）。
   其中顶点数据存储在缓存区（因为数量巨大），以修饰符attribute传递给顶点着色器；
   矩阵则以修饰符uniform传递给顶点着色器。



3. 生成顶点着色器
   根据我们需要，由Javascript定义一段顶点着色器（opengl es）程序的字符串，生成并且编译成一段着色器程序传递给GPU。

   生成片元着色器
   模型是什么颜色，看起来是什么质地，光照效果，阴影（流程较复杂，需要先渲染到纹理，可以先不关注），都在这个阶段处理。



4. 创建着色器方法（怎么和GPU交互？）

```js
function createShader(context,type,dataSource){
  const shader = context.createShader(type); // 创建着色器对象
  context.shaderSource(shader, dataSource); // 提供数据源
  context.compileShader(shader); // 编译 -> 生成着色器
  
  return shader; // 返回生成的着色器
}

//创建顶点着色器
const vertexShader = createShader(glContext, gl.VERTEX_SHADER, vertexShaderSource);

//创建片元着色器
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
```



5. 创建着色程序 （把两个着色器拼在一起，成为一个供GPU调用的程序）

```js
function createProgram(gl, vertexShader, fragmentShader) {
  //新建着色程序
  const program = gl.createProgram();
  
  //挂载着色器
  gl.attachShader(program, vertexShader); 
  gl.attachShader(program, fragmentShader);
  
  gl.linkProgram(program);
  
  return program;
}

const program = createProgram(gl, vertexShader, fragmentShader);
```

至此，GPU上就已经创建了一个GLSL着色程序，如果我们再向这个程序上提供数据，GPU就能进行相应的绘制。



6. 图元装配
   GPU根据顶点数量，挨个执行顶点着色器程序，生成顶点最终的坐标，完成坐标转换。

7. 光栅化
   能过片元着色器，我们确定好了每个片元的颜色，以及根据深度缓存区判断哪些片元被挡住了，不需要渲染，最终将片元信息存储到颜色缓存区，最终完成整个渲染。



# 场景

### 1. 移动端如何适配 1px

- 设备像素比：`dpr`=window.devicePixelRatio，也就是设备的物理像素与 CSS 像素的比值。

  如`dpr`为`2`，`css`里写的`1px`宽度映射到物理像素上就有`2px`宽度。

  这就造成了页面在不同机子上的不一致

- 借助`媒体查询`来处理 `screen -webkit-min-device-pixel-ratio: 2` 把相应的边作一个换算

- 使用相对 view-port 的单位

  在`<head>`中设置`<meta>` 更改它的`initial / max / min -scale`



### 2. 上传大文件

html5 提供的文件 API 中可以轻松的对文件进行分割切片

在 JavaScript 文件以文件对象`File`存在，而它的父类`Blob`可以提供一个`slice`方法，这样就能达到文件切分的目的；

为了把切分的文件组合，那么一般还要提供一个 ID 的字段，以及它们所在的集合信息`context`，id 可以拼接在后方，那服务端收到就可以拼装了。

要实现断点续传，则双方要在`context`,以及切分的 id 上达成共议，那就可以知道传到哪了，下次就可以再从未发送的文件块继续发了



# 其它

## 设计模式

### MVVM / MVC 模型

- MVC `Model-View-Controllor`

  - Model 用来存放数据
  - View 用来表现数据
  - Controllor 是中介，它指挥 Model 中的数据如何更新，也指挥 View 的变化
  - MVC 允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对 View 的操作交给了 Controller 处理，在 Controller 中响应 View 的事件调用 Model 的接口对数据进行操作，一旦 Model 发生变化便通知相关视图进行更新。
- MVP `Model-View-Presenter`
  - 表现者承载了UI，也就是View层的业务逻辑
  - 表现者主要做了以下这几件事：
    1. 从View中得到Data
    2. 修改Data
    3. 决定Data如何表现在View之上
- MVVM 与 MVC 最大的区别就是：

它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，

而是改变属性后该属性对应 View 层显示会自动改变。



Vue 是典型的 MVVM 模式

Vue 实例中的 data 相当于 Model 层，而 ViewModel 层的核心是 Vue 中的双向数据绑定，即 Model 变化时 VIew 可以实时更新，View 变化也能让 Model 发生变化



而React一般认为是MVVM中的V + VM层

# 数据结构和算法

## 数据结构



## 排序算法



。